////////////////////////////////////////////////////////////////////////////
// Name:        FrameCanvas.cpp
// Purpose:     Implmentation of Frame and Canvas
// Authors:     Paul Koning, Joe Stanton, Bill Galcher, Steve Zoppi, Dale Sinder
// Created:     03/26/2005
// Copyright:   (c) Paul Koning, Joe Stanton, Dale Sinder
// Licence:     see pterm-license.txt
/////////////////////////////////////////////////////////////////////////////

#include "CommonHeader.h"
#include "PtermFrame.h"
#include "PtermCanvas.h"
#include "PtermConnDialog.h"
#include "DebugPterm.h"
#include "PtermConnFailDialog.h"
#include "PtermPrefDialog.h"

/*
The key of the Pterm V5 design is that it just uses a 512x512 bitmap with
raw pixel access to construct most of the screen content, then it displays
that bitmap on the window.  Similarly, it displays that bitmap on the
printout, or processes it for save-screen, etc.  Display transformations
like stretch and 2x scale are done when that bitmap is displayed, not
by making the bitmap itself different.
*/

// ptermkeytabs.h is generated by composed.py.  It defines a number of
// character mapping tables:
// asciiToPlato maps ASCII (7 bit) keyboard character values to the
// corresponding PLATO key code(s).  Each entry is either None (ignored)
// or the KEY macro specifying up to four PLATO key codes, with None as 
// filler if less than four are needed.  Note that this table only has 
// entries for keystrokes whose shift handling is the same as in a 
// conventional ASCII keyboard.  For example, SPACE is not listed here
// (it is handled explicitly elsewhere in the code) because shift-SPACE
// is backspace.
// pastedAsciiToPlato -- same as asciiToPlato except that this one is
// used to map ASCII character codes found in paste strings.  Most
// control characters are unused here, and SPACE is a normal entry.
// unicodeToPlato -- a lookup table consisting of pairs; each entry is a 
// Unicode character code and the corresponding PLATO key sequence.
// The entries are in ascending order to allow for binary search, if
// desired.  There are entries here for precomposed characters (like 
// O with umlaut) as well as for the separate accent marks (like
// combining umlaut).
// autobsmap -- a lookup table of autobsentry items.  Each entry maps
// a sequence of up to 3 Unicode characters to a replacement Unicode
// character.  The inputs correspond to entries in the screen text map:
// characters plotted, including any autobackspaced bits like accents
// or parts of composite characters.  The output is the Unicode character
// we want to use for that sequence.

#include "ptermkeytabs.h"

// the application icon (under Windows and OS/2 it is in resources)
#if defined (__WXGTK__) || defined (__WXMOTIF__) || defined (__WXMAC__) || defined (__WXMGL__) || defined (__WXX11__)
#include "pterm_32.xpm"
#endif

// Keycode translation for ALT-keypress.  -1 means not valid.  Note that as
// a general rule, ALT and Control produce the same outcome (if control key
// accelerators are disabled).
const i8 altKeyToPlato[128] =
{
    /*                                                                         */
    /* 000- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*                                                                         */
    /* 010- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*                                                                         */
    /* 020- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*                                                                         */
    /* 030- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*          space   !       "       #       $       %       &       '      */
    /* 040- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*          (       )       *       +       ,       -       .       /      */
    /* 050- */ -1,     -1,     -1,      0056,  -1,      0057,  -1,     -1,
    /*          0       1       2       3       4       5       6       7      */
    /* 060- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*          8       9       :       ;       <       =       >       ?      */
    /* 070- */ -1,     -1,     -1,     -1,     -1,      0015,  -1,     -1,
    /*          @       A       B       C       D       E       F       G      */
    /* 100- */ -1,      0062,   0070,   0073,   0071,   0067,   0064,  0053,
    /*          H       I       J       K       L       M       N       O      */
    /* 110- */  0065,  -1,     -1,     -1,      0075,   0064,   0066,  -1,
    /*          P       Q       R       S       T       U       V       W      */
    /* 120- */ 0060,    0074,   0063,   0072,   0062,  -1,     -1,     -1,
    /*          X       Y       Z       [       \       ]       ^       _      */
    /* 130- */ 0052,    0061,  -1,     -1,     -1,     -1,     -1,     -1,
    /*          `       a       b       c       d       e       f       g      */
    /* 140- */ -1,      0022,   0030,   0033,   0031,   0027,   0064,  0013,
    /*          h       i       j       k       l       m       n       o      */
    /* 150- */  0025,  -1,     -1,     -1,      0035,   0024,   0026,  -1,
    /*          p       q       r       s       t       u       v       w      */
    /* 160- */ 0020,    0034,   0023,   0032,   0062,  -1,     -1,     -1,
    /*          x       y       z       {       |       }       ~              */
    /* 170- */ 0012,    0021,  -1,     -1,     -1,     -1,     -1,     -1
};

/*
**  This table is for translating PLATO text as it would appear in a
**  upper case only printout.  Shift shows up as a separate character (')
**  and has to be handled specially, and some other punctuation characters
**  have unexpected meanings:
**      "   multiply
**      #   divide
**      &   super
**      !   sub
**      ?   cr
**      \   font
**      ^   access
**      @   backspace
**      _   assign
**  In this table, the unshifted code values appear.  -1 means no
**  translation, -2 marks Shift.
*/
const int printoutToPlato[128] =
{
    /*                                                                         */
    /* 000- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*                                                                         */
    /* 010- */ -1,    014,    026,     -1,     -1,     -1,     -1,     -1,
    /*                                                                         */
    /* 020- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*                                                                         */
    /* 030- */ -1,     -1,     -1,     -1,     -1,     -1,     -1,     -1,
    /*          space   !       "       #       $       %       &       '      */
    /* 040- */  0100,   0021,   0012,   0013,   0044,   0045,   0020,  -2,
    /*          (       )       *       +       ,       -       .       /      */
    /* 050- */  0051,   0173,   0050,   0016,   0137,   0017,   0136,   0135,
    /*          0       1       2       3       4       5       6       7      */
    /* 060- */  0000,   0001,   0002,   0003,   0004,   0005,   0006,   0007,
    /*          8       9       :       ;       <       =       >       ?      */
    /* 070- */  0010,   0011,   0174,   0134,   0040,   0133,   0041,   0175,
    /*          @       A       B       C       D       E       F       G      */
    /* 100- */  0140,   0101,   0102,   0103,   0104,   0105,   0106,   0107,
    /*          H       I       J       K       L       M       N       O      */
    /* 110- */  0110,   0111,   0112,   0113,   0114,   0115,   0116,   0117,
    /*          P       Q       R       S       T       U       V       W      */
    /* 120- */  0120,   0121,   0122,   0123,   0124,   0125,   0126,   0127,
    /*          X       Y       Z       [       \       ]       ^       _      */
    /* 130- */  0130,   0131,   0132,   0042,   0064,   0043,   0074,   0015,
    /*          `       a       b       c       d       e       f       g      */
    /* 140- */ -1,      0101,   0102,   0103,   0104,   0105,   0106,   0107,
    /*          h       i       j       k       l       m       n       o      */
    /* 150- */  0110,   0111,   0112,   0113,   0114,   0115,   0116,   0117,
    /*          p       q       r       s       t       u       v       w      */
    /* 160- */  0120,   0121,   0122,   0123,   0124,   0125,   0126,   0127,
    /*          x       y       z       {       |       }       ~              */
    /* 170- */  0130,   0131,   0132,  -1,     -1,     -1,     -1,     -1,
};

// A bunch of these characters are outside the ASCII set, so they are
// written as Unicode escapes.  Too bad C doesn't accept plain Unicode
// text inside quoted strings, as Python does.  Comments say what characters
// those escapes reference.
// The first 64 characters are for the set 0 codes; the rest are for
// the set 1 codes.  Codes past offset 64 in set 1 correspond to the
// "special" characters in ASCII mode, which are essentially built-in
// composites that on a Classic terminal would be made by the formatter.
// Here we just treat them as extra characters for simplicity.
static const wxChar rom01char[] =
L":abcdefg"
L"hijklmno"
L"pqrstuvw"
L"xyz01234"
L"56789+-*"
L"/()$= ,."
L"\u00F7[]%\u00D7\u21E6'\""     // divide, multiply, left arrow (assign)
L"!;<>_?\u2AA2 "                // double greater than (plato "arrow")
L"#ABCDEFG"
L"HIJKLMNO"
L"PQRSTUVW"
L"XYZ\u02DC\u00A8^\u00B4`"      // small tilde, dieresis, acute
L"\u2191\u2192\u2193\u2190"     // up, right, down, left arrow
L"~\u03A3\u0394\u222A"          // Sigma, Delta, union
L"\u2229{}&\u2260 |\u00B0"      // intersection, not-equal, degree
L"\u2263\u03B1\u03B2\u03B4"     // equiv, alpha, beta, delta
L"\u03BB\u03BC\u03C0\u03C1"     // lambda, mu, pi, rho
L"\u03C3\u03C9\u2264\u2265"     // sigma, omega, less/equal, grt/equal
L"\u0398@\\ "                   // Theta
L"\u2993\u2994\u00A9\u25AB"     // embed left, right, copyright, box
L"\u25C6\u2715\u02C7\u2195"     // diamond, cross prod, hacek, up/down
L"\u25CB\u00B8";               // dot product, cedilla

                               // Tables to map ASCII characters to the correct character image.  There
                               // are two tables, one for the M0 set, one for the M1 set.  Note that
                               // these sets do not directly correspond to the classic terminal sets.
                               // Each table is indexed by the ASCII character code (7 bit value).
                               //
                               // The value found in the table is the classic ROM character index for
                               // this character, in the low 7 bits.  The top bit selects M0 vs. M1
                               // in the classic ROM.  0xff means unused code.
                               //
                               // Codes 0xc0 and up are specials (ASCII only extra character codes); in
                               // the classic terminal these are instead formatted as sequences or codes
                               // with displayed Y position, but in ASCII they are directly coded as 
                               // additional characters.  We simply handle these as additional character
                               // shapes, stored in the M1 character ROM data beyond the usual 64 entries.
                               //
                               // 0xc0: embed left
                               // 0xc1: embed right
                               // 0xc2: copyright body
                               // 0xc3: box
                               // 0xc4: diamond
                               // 0xc5: cross product
                               // 0xc6: hacek
                               // 0xc7: universal delimiter
                               // 0xc8: dot product
                               // 0xc9: cedilla

static const u8 asciiM0[] =
{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x2d, 0x38, 0x37, 0x80, 0x2b, 0x33, 0xab, 0x36,
0x29, 0x2a, 0x27, 0x25, 0x2e, 0x26, 0x2f, 0x28,
0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
0x23, 0x24, 0x00, 0x39, 0x3a, 0x2c, 0x3b, 0x3d,
0xbd, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x31, 0xbe, 0x32, 0x9d, 0x3c,
0x9f, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0xa9, 0xae, 0xaa, 0xa4, 0xff
};
static const u8 asciiM1[] =
{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x2d, 0x28, 0xb0, 0x9b, 0x35, 0xac, 0xa0, 0xa1,
0xa2, 0xa3, 0x34, 0xa5, 0xa6, 0xa7, 0xa8, 0x30,
0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
0xb9, 0xba, 0xbb, 0xbc, 0xc0, 0xaf, 0xc1, 0x3e,
0xc2, 0x9c, 0xc3, 0xc8, 0xc4, 0xc5, 0x9e, 0xc9,
0xc6, 0xc7, 0xae, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
static const u8 asciiKeycodes[] =
{ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x26, 0x60, 0x0a, 0x5e, 0x2b, 0x2d,
0x13, 0x04, 0x07, 0x08, 0x7b, 0x0b, 0x0d, 0x1a,
0x02, 0x12, 0x01, 0x03, 0x7d, 0x0c, 0xff, 0xff,
0x3c, 0x3e, 0x5b, 0x5d, 0x24, 0x25, 0x5f, 0x7c,
0x2a, 0x28, 0x40, 0x27, 0x1c, 0x5c, 0x23, 0x7e,
0x17, 0x05, 0x14, 0x19, 0x7f, 0x09, 0x1e, 0x18,
0x0e, 0x1d, 0x11, 0x16, 0x00, 0x0f, 0xff, 0xff,
0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x3d, 0x3b, 0x2f, 0x2e, 0x2c,
0x1f, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x29, 0x3a, 0x3f, 0x21, 0x22
};

// Conversion from ascii mode codes to classic codes
static const u8 ascmode[] = { 0, 3, 2, 1 };

/* data for plato font, set 0. */
const unsigned short plato_m0[] = {
    0x0000, 0x0000, 0x0330, 0x0330, 0x0000, 0x0000, 0x0000, 0x0000, // :
    0x0060, 0x0290, 0x0290, 0x0290, 0x0290, 0x01e0, 0x0010, 0x0000, // a
    0x1ff0, 0x0120, 0x0210, 0x0210, 0x0210, 0x0120, 0x00c0, 0x0000, // b
    0x00c0, 0x0120, 0x0210, 0x0210, 0x0210, 0x0210, 0x0120, 0x0000, // c
    0x00c0, 0x0120, 0x0210, 0x0210, 0x0210, 0x0120, 0x1ff0, 0x0000, // d
    0x00c0, 0x01a0, 0x0290, 0x0290, 0x0290, 0x0290, 0x0190, 0x0000, // e
    0x0000, 0x0000, 0x0210, 0x0ff0, 0x1210, 0x1000, 0x0800, 0x0000, // f
    0x01a8, 0x0254, 0x0254, 0x0254, 0x0254, 0x0194, 0x0208, 0x0000, // g
    0x1000, 0x1ff0, 0x0100, 0x0200, 0x0200, 0x0200, 0x01f0, 0x0000, // h
    0x0000, 0x0000, 0x0210, 0x13f0, 0x0010, 0x0000, 0x0000, 0x0000, // i
    0x0000, 0x0002, 0x0202, 0x13fc, 0x0000, 0x0000, 0x0000, 0x0000, // j
    0x1010, 0x1ff0, 0x0080, 0x0140, 0x0220, 0x0210, 0x0010, 0x0000, // k
    0x0000, 0x0000, 0x1010, 0x1ff0, 0x0010, 0x0000, 0x0000, 0x0000, // l
    0x03f0, 0x0200, 0x0200, 0x01f0, 0x0200, 0x0200, 0x01f0, 0x0000, // m
    0x0200, 0x03f0, 0x0100, 0x0200, 0x0200, 0x0200, 0x01f0, 0x0000, // n
    0x00c0, 0x0120, 0x0210, 0x0210, 0x0210, 0x0120, 0x00c0, 0x0000, // o
    0x03fe, 0x0120, 0x0210, 0x0210, 0x0210, 0x0120, 0x00c0, 0x0000, // p
    0x00c0, 0x0120, 0x0210, 0x0210, 0x0210, 0x0120, 0x03fe, 0x0000, // q
    0x0200, 0x03f0, 0x0100, 0x0200, 0x0200, 0x0200, 0x0100, 0x0000, // r
    0x0120, 0x0290, 0x0290, 0x0290, 0x0290, 0x0290, 0x0060, 0x0000, // s
    0x0200, 0x0200, 0x1fe0, 0x0210, 0x0210, 0x0210, 0x0000, 0x0000, // t
    0x03e0, 0x0010, 0x0010, 0x0010, 0x0010, 0x03e0, 0x0010, 0x0000, // u
    0x0200, 0x0300, 0x00c0, 0x0030, 0x00c0, 0x0300, 0x0200, 0x0000, // v
    0x03e0, 0x0010, 0x0020, 0x01c0, 0x0020, 0x0010, 0x03e0, 0x0000, // w
    0x0200, 0x0210, 0x0120, 0x00c0, 0x00c0, 0x0120, 0x0210, 0x0000, // x
    0x0382, 0x0044, 0x0028, 0x0010, 0x0020, 0x0040, 0x0380, 0x0000, // y
    0x0310, 0x0230, 0x0250, 0x0290, 0x0310, 0x0230, 0x0000, 0x0000, // z
    0x0010, 0x07e0, 0x0850, 0x0990, 0x0a10, 0x07e0, 0x0800, 0x0000, // 0
    0x0000, 0x0000, 0x0410, 0x0ff0, 0x0010, 0x0000, 0x0000, 0x0000, // 1
    0x0000, 0x0430, 0x0850, 0x0890, 0x0910, 0x0610, 0x0000, 0x0000, // 2
    0x0000, 0x0420, 0x0810, 0x0910, 0x0910, 0x06e0, 0x0000, 0x0000, // 3
    0x0000, 0x0080, 0x0180, 0x0280, 0x0480, 0x0ff0, 0x0080, 0x0000, // 4
    0x0000, 0x0f10, 0x0910, 0x0910, 0x0920, 0x08c0, 0x0000, 0x0000, // 5
    0x0000, 0x03e0, 0x0510, 0x0910, 0x0910, 0x00e0, 0x0000, 0x0000, // 6
    0x0000, 0x0800, 0x0830, 0x08c0, 0x0b00, 0x0c00, 0x0000, 0x0000, // 7
    0x0000, 0x06e0, 0x0910, 0x0910, 0x0910, 0x06e0, 0x0000, 0x0000, // 8
    0x0000, 0x0700, 0x0890, 0x0890, 0x08a0, 0x07c0, 0x0000, 0x0000, // 9
    0x0000, 0x0080, 0x0080, 0x03e0, 0x0080, 0x0080, 0x0000, 0x0000, // +
    0x0000, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080, 0x0000, 0x0000, // -
    0x0000, 0x0240, 0x0180, 0x0660, 0x0180, 0x0240, 0x0000, 0x0000, // *
    0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200, 0x0400, 0x0000, // /
    0x0000, 0x0000, 0x0000, 0x0000, 0x07e0, 0x0810, 0x1008, 0x0000, // (
    0x1008, 0x0810, 0x07e0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // )
    0x0640, 0x0920, 0x0920, 0x1ff0, 0x0920, 0x0920, 0x04c0, 0x0000, // $
    0x0000, 0x0140, 0x0140, 0x0140, 0x0140, 0x0140, 0x0000, 0x0000, // =
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // space
    0x0000, 0x0000, 0x0034, 0x0038, 0x0000, 0x0000, 0x0000, 0x0000, // ,
    0x0000, 0x0000, 0x0030, 0x0030, 0x0000, 0x0000, 0x0000, 0x0000, // .
    0x0000, 0x0080, 0x0080, 0x02a0, 0x0080, 0x0080, 0x0000, 0x0000, // divide
    0x0000, 0x0000, 0x0000, 0x0000, 0x1ff8, 0x1008, 0x1008, 0x0000, // [
    0x1008, 0x1008, 0x1ff8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // ]
    0x0c20, 0x1240, 0x0c80, 0x0100, 0x0260, 0x0490, 0x0860, 0x0000, // %
    0x0000, 0x0000, 0x0240, 0x0180, 0x0180, 0x0240, 0x0000, 0x0000, // multiply
    0x0080, 0x0140, 0x0220, 0x0770, 0x0140, 0x0140, 0x0140, 0x0000, // assign
    0x0000, 0x0000, 0x0000, 0x1c00, 0x0000, 0x0000, 0x0000, 0x0000, // '
    0x0000, 0x0000, 0x1c00, 0x0000, 0x1c00, 0x0000, 0x0000, 0x0000, // "
    0x0000, 0x0000, 0x0000, 0x1f90, 0x0000, 0x0000, 0x0000, 0x0000, // !
    0x0000, 0x0000, 0x0334, 0x0338, 0x0000, 0x0000, 0x0000, 0x0000, // ;
    0x0000, 0x0080, 0x0140, 0x0220, 0x0410, 0x0000, 0x0000, 0x0000, // <
    0x0000, 0x0000, 0x0410, 0x0220, 0x0140, 0x0080, 0x0000, 0x0000, // >
    0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, // _
    0x0000, 0x0c00, 0x1000, 0x10d0, 0x1100, 0x0e00, 0x0000, 0x0000, // ?
    0x1c1c, 0x1224, 0x0948, 0x0490, 0x0220, 0x0140, 0x0080, 0x0000, // arrow
    0x0000, 0x0000, 0x0000, 0x000a, 0x0006, 0x0000, 0x0000, 0x0000, // cedilla
};

/* data for plato font, set 1. */
const unsigned short plato_m1[] = {
    0x0500, 0x0500, 0x1fc0, 0x0500, 0x1fc0, 0x0500, 0x0500, 0x0000, // #
    0x07f0, 0x0900, 0x1100, 0x1100, 0x1100, 0x0900, 0x07f0, 0x0000, // A
    0x1ff0, 0x1210, 0x1210, 0x1210, 0x1210, 0x0e10, 0x01e0, 0x0000, // B
    0x07c0, 0x0820, 0x1010, 0x1010, 0x1010, 0x1010, 0x0820, 0x0000, // C
    0x1ff0, 0x1010, 0x1010, 0x1010, 0x1010, 0x0820, 0x07c0, 0x0000, // D
    0x1ff0, 0x1110, 0x1110, 0x1110, 0x1010, 0x1010, 0x1010, 0x0000, // E
    0x1ff0, 0x1100, 0x1100, 0x1100, 0x1000, 0x1000, 0x1000, 0x0000, // F
    0x07c0, 0x0820, 0x1010, 0x1010, 0x1090, 0x1090, 0x08e0, 0x0000, // G
    0x1ff0, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x1ff0, 0x0000, // H
    0x0000, 0x1010, 0x1010, 0x1ff0, 0x1010, 0x1010, 0x0000, 0x0000, // I
    0x0020, 0x0010, 0x1010, 0x1010, 0x1fe0, 0x1000, 0x1000, 0x0000, // J
    0x1ff0, 0x0080, 0x0100, 0x0280, 0x0440, 0x0820, 0x1010, 0x0000, // K
    0x1ff0, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0000, // L
    0x1ff0, 0x0800, 0x0400, 0x0200, 0x0400, 0x0800, 0x1ff0, 0x0000, // M
    0x1ff0, 0x0800, 0x0600, 0x0100, 0x00c0, 0x0020, 0x1ff0, 0x0000, // N
    0x07c0, 0x0820, 0x1010, 0x1010, 0x1010, 0x0820, 0x07c0, 0x0000, // O
    0x1ff0, 0x1100, 0x1100, 0x1100, 0x1100, 0x1100, 0x0e00, 0x0000, // P
    0x07c0, 0x0820, 0x1010, 0x1018, 0x1014, 0x0824, 0x07c0, 0x0000, // Q
    0x1ff0, 0x1100, 0x1100, 0x1180, 0x1140, 0x1120, 0x0e10, 0x0000, // R
    0x0e20, 0x1110, 0x1110, 0x1110, 0x1110, 0x1110, 0x08e0, 0x0000, // S
    0x1000, 0x1000, 0x1000, 0x1ff0, 0x1000, 0x1000, 0x1000, 0x0000, // T
    0x1fe0, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x1fe0, 0x0000, // U
    0x1800, 0x0700, 0x00c0, 0x0030, 0x00c0, 0x0700, 0x1800, 0x0000, // V
    0x1fe0, 0x0010, 0x0020, 0x03c0, 0x0020, 0x0010, 0x1fe0, 0x0000, // W
    0x1830, 0x0440, 0x0280, 0x0100, 0x0280, 0x0440, 0x1830, 0x0000, // X
    0x1800, 0x0400, 0x0200, 0x01f0, 0x0200, 0x0400, 0x1800, 0x0000, // Y
    0x1830, 0x1050, 0x1090, 0x1110, 0x1210, 0x1410, 0x1830, 0x0000, // Z
    0x0000, 0x1000, 0x2000, 0x2000, 0x1000, 0x1000, 0x2000, 0x0000, // ~
    0x0000, 0x0000, 0x1000, 0x0000, 0x1000, 0x0000, 0x0000, 0x0000, // dieresis
    0x0000, 0x1000, 0x2000, 0x4000, 0x2000, 0x1000, 0x0000, 0x0000, // circumflex
    0x0000, 0x0000, 0x0000, 0x1000, 0x2000, 0x4000, 0x0000, 0x0000, // acute
    0x0000, 0x4000, 0x2000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, // grave
    0x0000, 0x0100, 0x0300, 0x07f0, 0x0300, 0x0100, 0x0000, 0x0000, // uparrow
    0x0080, 0x0080, 0x0080, 0x0080, 0x03e0, 0x01c0, 0x0080, 0x0000, // rtarrow 
    0x0000, 0x0040, 0x0060, 0x07f0, 0x0060, 0x0040, 0x0000, 0x0000, // downarrow
    0x0080, 0x01c0, 0x03e0, 0x0080, 0x0080, 0x0080, 0x0080, 0x0000, // leftarrow
    0x0000, 0x0080, 0x0100, 0x0100, 0x0080, 0x0080, 0x0100, 0x0000, // low tilde
    0x1010, 0x1830, 0x1450, 0x1290, 0x1110, 0x1010, 0x1010, 0x0000, // Sigma
    0x0030, 0x00d0, 0x0310, 0x0c10, 0x0310, 0x00d0, 0x0030, 0x0000, // Delta
    0x0000, 0x0380, 0x0040, 0x0040, 0x0040, 0x0380, 0x0000, 0x0000, // union
    0x0000, 0x01c0, 0x0200, 0x0200, 0x0200, 0x01c0, 0x0000, 0x0000, // intersect
    0x0000, 0x0000, 0x0000, 0x0080, 0x0f78, 0x1004, 0x1004, 0x0000, // {
    0x1004, 0x1004, 0x0f78, 0x0080, 0x0000, 0x0000, 0x0000, 0x0000, // }
    0x00e0, 0x0d10, 0x1310, 0x0c90, 0x0060, 0x0060, 0x0190, 0x0000, // &
    0x0150, 0x0160, 0x0140, 0x01c0, 0x0140, 0x0340, 0x0540, 0x0000, // not equal
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // space
    0x0000, 0x0000, 0x0000, 0x1ff0, 0x0000, 0x0000, 0x0000, 0x0000, // |
    0x0000, 0x0c00, 0x1200, 0x1200, 0x0c00, 0x0000, 0x0000, 0x0000, // degree
    0x0000, 0x02a0, 0x02a0, 0x02a0, 0x02a0, 0x02a0, 0x0000, 0x0000, // equiv
    0x01e0, 0x0210, 0x0210, 0x01a0, 0x0060, 0x0090, 0x0310, 0x0000, // alpha
    0x0002, 0x03fc, 0x0510, 0x0910, 0x0910, 0x0690, 0x0060, 0x0000, // beta
    0x0000, 0x0ce0, 0x1310, 0x1110, 0x0890, 0x0460, 0x0000, 0x0000, // delta
    0x0000, 0x1030, 0x0cc0, 0x0300, 0x00c0, 0x0030, 0x0000, 0x0000, // lambda
    0x0002, 0x0002, 0x03fc, 0x0010, 0x0010, 0x03e0, 0x0010, 0x0000, // mu
    0x0100, 0x0200, 0x03f0, 0x0200, 0x03f0, 0x0200, 0x0400, 0x0000, // pi
    0x0006, 0x0038, 0x00e0, 0x0110, 0x0210, 0x0220, 0x01c0, 0x0000, // rho
    0x00e0, 0x0110, 0x0210, 0x0310, 0x02e0, 0x0200, 0x0200, 0x0000, // sigma
    0x01e0, 0x0210, 0x0010, 0x00e0, 0x0010, 0x0210, 0x01e0, 0x0000, // omega
    0x0220, 0x0220, 0x0520, 0x0520, 0x08a0, 0x08a0, 0x0000, 0x0000, // less/equal
    0x0000, 0x08a0, 0x08a0, 0x0520, 0x0520, 0x0220, 0x0220, 0x0000, // greater/equal
    0x07c0, 0x0920, 0x1110, 0x1110, 0x1110, 0x0920, 0x07c0, 0x0000, // theta
    0x01e0, 0x0210, 0x04c8, 0x0528, 0x05e8, 0x0220, 0x01c0, 0x0000, // @
    0x0400, 0x0200, 0x0100, 0x0080, 0x0040, 0x0020, 0x0010, 0x0000, /* \ */
    0x01e0, 0x0210, 0x0210, 0x01e0, 0x0290, 0x0290, 0x01a0, 0x0000, // oe

    // "Special" character patterns: these are beyond the regular
    // 6-bit character indices, and are used when "special" ASCII
    // mode characters are encountered.  Rather than display them
    // from pieces, we just treat them as additional character
    // patterns.
    0x0000, 0x0080, 0x0140, 0x0220, 0x07f0, 0x0810, 0x1008, 0x0000, // l-embed
    0x1008, 0x0810, 0x07f0, 0x0220, 0x0140, 0x0080, 0x0000, 0x0000, // r-embed
    0x2184, 0x2244, 0x2424, 0x2424, 0x2424, 0x2424, 0x2244, 0x2004, // copyright
    0x0000, 0x03c0, 0x0240, 0x0240, 0x0240, 0x03c0, 0x0000, 0x0000, // box
    0x0080, 0x01c0, 0x03e0, 0x07f0, 0x03e0, 0x01c0, 0x0080, 0x0000, // diamond
    0x0410, 0x0220, 0x0140, 0x0080, 0x0140, 0x0220, 0x0410, 0x0000, // cross
    0x0000, 0x4000, 0x2000, 0x1000, 0x2000, 0x4000, 0x0000, 0x0000, // hacek
    0x0000, 0x0140, 0x0360, 0x07f0, 0x0360, 0x0140, 0x0000, 0x0000, // delim
    0x0000, 0x0180, 0x0240, 0x0240, 0x0180, 0x0000, 0x0000, 0x0000, // dot prod
    0x0000, 0x0000, 0x0000, 0x0002, 0x0004, 0x0008, 0x0000, 0x0000, // cedilla
};


// On Mac, Arial is not a standard font, so you get warnings about
// partial matches.  Helvetica is, though (and besides, that's what
// Arial really is) so use that name on Mac.
#if defined (__WXMAC__)
#define SSFONT "Helvetica"
#else
#define SSFONT "Arial"
#endif


// ----------------------------------------------------------------------------
// event tables and other macros for wxWindows
// ----------------------------------------------------------------------------

// the event tables connect the wxWindows events with the functions (event
// handlers) which process them. It can be also done at run-time, but for the
// simple menu events like this the static method is much simpler.
BEGIN_EVENT_TABLE (PtermFrame, wxFrame)
    EVT_IDLE (PtermFrame::OnIdle)
    EVT_CLOSE (PtermFrame::OnClose)
    EVT_TIMER (Pterm_Timer, PtermFrame::OnTimer)
    EVT_TIMER (Pterm_Mclock, PtermFrame::OnMclock)
    EVT_TIMER (Pterm_Dclock, PtermFrame::OnDclock)
    EVT_TIMER (Pterm_Mz80, PtermFrame::OnMz80)
    EVT_TIMER (Pterm_PasteTimer, PtermFrame::OnPasteTimer)
    EVT_ACTIVATE (PtermFrame::OnActivate)
    EVT_MENU (Pterm_ConnectAgain, PtermFrame::OnConnectAgain)
    EVT_MENU (Pterm_Close, PtermFrame::OnQuit)
#if !defined (__WXMAC__)
    EVT_MENU (Pterm_ToggleMenuBar, PtermFrame::OnToggleMenuBar)
#endif
    EVT_MENU (Pterm_ToggleStatusBar, PtermFrame::OnToggleStatusBar)
    // The scale handler is set dynamically when the view menu is built
    //EVT_MENU (Pterm_SetScaleEntry, PtermFrame::OnSetScaleEntry)
    EVT_MENU (Pterm_ToggleStretchMode, PtermFrame::OnSetStretchMode)
    EVT_MENU (Pterm_ToggleAspectMode, PtermFrame::OnSetAspectMode)
    EVT_MENU (Pterm_CopyScreen, PtermFrame::OnCopyScreen)
    EVT_MENU (Pterm_ToggleLock, PtermFrame::OnLockPosition)
    EVT_MENU (Pterm_RestoreLocation, PtermFrame::OnRestorePosition)
    EVT_MENU (Pterm_Copy, PtermFrame::OnCopy)
    EVT_MENU (Pterm_Exec, PtermFrame::OnExec)    
    EVT_MENU (Pterm_MailTo, PtermFrame::OnMailTo)    
    EVT_MENU (Pterm_SearchThis, PtermFrame::OnSearchThis)    
    EVT_MENU (Pterm_Macro0, PtermFrame::OnMacro0)    
    EVT_MENU (Pterm_Macro1, PtermFrame::OnMacro1)    
    EVT_MENU (Pterm_Macro2, PtermFrame::OnMacro2)    
    EVT_MENU (Pterm_Macro3, PtermFrame::OnMacro3)    
    EVT_MENU (Pterm_Macro4, PtermFrame::OnMacro4)    
    EVT_MENU (Pterm_Macro5, PtermFrame::OnMacro5)    
    EVT_MENU (Pterm_Macro6, PtermFrame::OnMacro6)    
    EVT_MENU (Pterm_Macro7, PtermFrame::OnMacro7)    
    EVT_MENU (Pterm_Macro8, PtermFrame::OnMacro8)    
    EVT_MENU (Pterm_Macro9, PtermFrame::OnMacro9)    
    EVT_MENU (Pterm_Paste, PtermFrame::OnPaste)
    EVT_MENU (Pterm_PastePrint, PtermFrame::OnPaste)
    EVT_UPDATE_UI (Pterm_Paste, PtermFrame::OnUpdateUIPaste)
    EVT_MENU (Pterm_SaveScreen, PtermFrame::OnSaveScreen)
    EVT_MENU (Pterm_SaveAudio, PtermFrame::OnSaveAudio)
    EVT_MENU (Pterm_Print, PtermFrame::OnPrint)
    EVT_MENU (Pterm_ResetMtutor, PtermFrame::OnReset)
    EVT_MENU (Pterm_SessionSettings, PtermFrame::OnSessionSettings)
    EVT_MENU (Pterm_Preview, PtermFrame::OnPrintPreview)
    EVT_MENU (Pterm_Page_Setup, PtermFrame::OnPageSetup)
    EVT_MENU (Pterm_FullScreen, PtermFrame::OnFullScreen)
    EVT_SIZE (PtermFrame::OnResize)
#if defined (__WXMSW__)
    EVT_ICONIZE (PtermFrame::OnIconize)
#endif
    END_EVENT_TABLE ();
// ----------------------------------------------------------------------------
// PtermCanvas
// ----------------------------------------------------------------------------

// For Retina display support on the Mac, the set of available scale
// values is different than elsewhere; specifically, half-integer values
// make sense because each display unit is actually two pixels. 
const double scaleList_Retina[] = { 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, -1. };
const double scaleList_std[] = { 1.0, 2.0, 3.0, -1 };
const double *scaleList;

// the event tables connect the wxWindows events with the functions (event
// handlers) which process them.
BEGIN_EVENT_TABLE (PtermCanvas, wxScrolledCanvas)
    EVT_CHAR (PtermCanvas::OnChar)
    EVT_CHAR_HOOK (PtermCanvas::OnCharHook)
    EVT_LEFT_DOWN (PtermCanvas::OnMouseDown)
    EVT_LEFT_UP (PtermCanvas::OnMouseUp)
    EVT_RIGHT_UP (PtermCanvas::OnMouseContextMenu)
    EVT_MOTION (PtermCanvas::OnMouseMotion)
    EVT_MOUSEWHEEL (PtermCanvas::OnMouseWheel)
    END_EVENT_TABLE ();

PtermCanvas::PtermCanvas (PtermFrame *parent)
    : wxScrolledCanvas (parent, -1, wxDefaultPosition, 
                        wxDefaultSize,
                        wxHSCROLL | wxVSCROLL | wxWANTS_CHARS
                        /* , "Default Name" */),
      m_mouseX (-1),
      m_mouseY (-1),
      m_owner (parent),
      m_touchEnabled (false)
{
    wxClientDC dc (this);

    DisableKeyboardScrolling ();
    SetBackgroundColour (m_owner->m_bgColor);
}

// Convert device x/y (on the scrolled canvas) to PLATO x/y.  This
// takes into account the current scroll position as well as scaling.
void PtermCanvas::Unadjust (int x, int y, int *xx, int *yy) const
{
    int xu, yu;

    CalcUnscrolledPosition (x, y, &xu, &yu);
    debug ("scrolled %d, %d maps to %d %d", x, y, xu, yu);

    *xx = xu / m_owner->m_xscale - m_owner->m_xmargin;
    *yy = 511 - (yu / m_owner->m_yscale - m_owner->m_ymargin);
}

void PtermCanvas::OnDraw (wxDC &dc)
{
    const int rh = m_owner->m_regionHeight;
    const int rw = m_owner->m_regionWidth;
    const int PScale = m_owner->GetContentScaleFactor ();
    
    dc.DestroyClippingRegion ();

    if (PScale == 1 || m_owner->m_xscale < 1 ||
        m_owner->m_yscale < 1)
    {
        // simple scaling
        if (!m_owner->m_FancyScaling ||
            ((m_owner->m_xscale == 1 && m_owner->m_yscale == 1) ||
            (m_owner->m_xscale == 2 && m_owner->m_yscale == 2) ||
            (m_owner->m_xscale == 3 && m_owner->m_yscale == 3))
            )
        {
            dc.SetUserScale (m_owner->m_xscale, m_owner->m_yscale);
            if (!m_owner->m_fullScreen)
            {
                dc.SetClippingRegion (m_owner->m_xmargin,
                    m_owner->m_ymargin, 512, 512);
            }
            dc.DrawBitmap (*m_owner->m_bitmap, m_owner->m_xmargin,
                m_owner->m_ymargin, false);
        }
        // BILINEAR scaling 
        else
        {
            int x1 = m_owner->m_xmargin + (m_owner->m_xscale - 1)*m_owner->m_xmargin;
            int y1 = m_owner->m_ymargin + (m_owner->m_yscale - 1)*m_owner->m_ymargin;
            wxImage scaleImage = m_owner->m_bitmap->ConvertToImage ();
            wxImage rescaledImage =  scaleImage.Scale (m_owner->m_xscale * 512,
                m_owner->m_yscale * 512,
                wxIMAGE_QUALITY_BILINEAR);
             if (!m_owner->m_fullScreen)
            {
                dc.SetClippingRegion (x1, y1,
                    m_owner->m_xscale * 512, m_owner->m_yscale * 512);
            }
            dc.DrawBitmap (rescaledImage, x1, y1, false);
        }
    }
    else
    {
        PixelData pixmap (*m_owner->m_bitmap);
        PixelData pixmap2 (*m_owner->m_bitmap2);
        PixelData::Iterator p (pixmap);
        PixelData::Iterator p2 (pixmap2);
        PixelData::Iterator p2b (pixmap2);
        u32 *pmap, *pmap2;
        u32 pd;
        int i, j;
        
        for (i = 0; i < 512; i++)
        {
            for (j = 0; j < 512; j++)
            {
                p.MoveTo (pixmap, j, i);
                p2.MoveTo (pixmap2, j * 2, i * 2);
                pd = *(u32 *) (p.m_ptr);
                pmap2 = (u32 *) (p2.m_ptr);
                *pmap2++ = pd;
                *pmap2   = pd;
            }
            p2.MoveTo (pixmap2, 0, i * 2);
            p2b.MoveTo (pixmap2, 0, i * 2 + 1);
            pmap = (u32 *) (p2.m_ptr);
            pmap2 = (u32 *) (p2b.m_ptr);
            memcpy (pmap2, pmap, 2 * 512 * sizeof (u32));
        }
        dc.SetUserScale (m_owner->m_xscale / PScale,
                         m_owner->m_yscale / PScale);
        if (!m_owner->m_fullScreen)
        {
            dc.SetClippingRegion (m_owner->m_xmargin * PScale, 
                                  m_owner->m_ymargin * PScale,
                                  512 * PScale, 512 * PScale);
        }
        dc.DrawBitmap (*m_owner->m_bitmap2,
                       m_owner->m_xmargin * PScale,
                       m_owner->m_ymargin * PScale, false);
    }
    
    debug ("Drawing bitmap onto the window canvas");

    if (rh != 0 && rw != 0)
    {
        dc.SetUserScale (m_owner->m_xscale, m_owner->m_yscale);
        dc.SetClippingRegion (m_owner->m_xmargin + (8 * m_owner->m_regionX), 
                              m_owner->m_ymargin + 511 -
                              (16 * (m_owner->m_regionY + rh)), 
                              rw * 8, rh * 16);
        dc.DrawBitmap (*m_owner->m_selmap, m_owner->m_xmargin,
                       m_owner->m_ymargin, false);
        dc.DestroyClippingRegion ();
    
        debug ("Drawing selection region, top %d %d, size %d %d",
                m_owner->m_regionX, m_owner->m_regionY, rw, rh);
    }
}

void PtermCanvas::OnCharHook (wxKeyEvent &event)
{
    unsigned int key;
    int shift = 0;
    u32 pc = None;
    bool ctrl;

    // Most keyboard inputs are handled here, because if we defer them to
    // a later stage, wrong things happen on Mac. 
    //
    // The one thing we do defer until EVT_CHAR is plain old characters, i.e.,
    // keystrokes that aren't function keys or other special keys, and
    // neither Ctrl nor Alt are active.

    if (m_owner->m_bPasteActive)
    {
        // If pasting is active, this key is NOT passed on to the application
        // until the paste operation is properly canceled
        m_owner->m_bCancelPaste = true;
        return;
    }

    ctrl = event.RawControlDown ();
    if (event.ShiftDown ())
    {
        shift = 040;
    }
    key = event.GetKeyCode ();

#if defined (__WXMAC__)
    if (event.ControlDown ())
    {
        // Command is in effect, that's a Mac keyboard shortcut,
        // let Mac sort it out.
        if (key == 'M')
        {
            // One exception: Cmd-M (minimize window) isn't handled in the
            // external machinery so I guess it has to be done here.
            if (event.AltDown ())
            {
                // Cmd-Option-M: minimize all
                for (PtermFrame *frame = ptermApp->m_firstFrame; 
                     frame != NULL;
                     frame = frame->m_nextFrame)
                {
                    frame->Iconize ();
                }
                if (ptermApp->m_helpFrame != NULL)
                {
                    ptermApp->m_helpFrame->Iconize ();
                }
            }
            else
            {
                m_owner->Iconize ();
            }
            return;
        }
        event.Skip ();
        return;
    }
#endif

    if (m_owner->IgnoreKeys() ||
        key == WXK_ALT ||
        key == WXK_SHIFT ||
        key == WXK_CONTROL ||
        key == WXK_RAW_CONTROL)
    {
        // We don't take any action on the modifier key keydown events,
        // but we do want to make sure they are seen by the rest of
        // the system.
        // The same applies to keys sent to the help window (which has
        // no connection on which to send them).
        //
        // Note that wxWidgets V3 maps the Mac Command key to WXK_CONTROL,
        // "to improve compatibility with other systems".  Gah.  But
        // fortunately, WXK_RAW_CONTROL means the real control key.

        event.Skip ();
        return;
    }

    if (key < 0200 && isalpha (key))
    {
        key = tolower (key);
    }

#if 0
    tracex ("oncharhook: ctrl %d shift %d alt %d key %d\n",
            event.RawControlDown (), event.ShiftDown (),
            event.AltDown (), key);
#endif

    if (event.ShiftDown ())
    {
        shift = 040;
    }

    // Special case: ALT-left or Ctrl-left is assignment arrow
    if ((event.AltDown () || event.RawControlDown ()) && key == WXK_LEFT)
    {
        m_owner->ptermSendKey1 (015 | shift);
        return;
    }

    if ((key < sizeof (altKeyToPlato) / sizeof (altKeyToPlato[0]) && 
         event.AltDown ()))
    {
        if (shift != 0 && key == '=')
        {
            key = '+';
        }
        if (altKeyToPlato[key] != -1)
        {
            m_owner->ptermSendKey1 (altKeyToPlato[key] | shift);
            return;
        }
    }
    else if (event.AltDown ())
    {
        // All ALT cases are handled above, so if we haven't handled
        // it yet and it's an Alt, let someone else see it.
        event.Skip ();
        return;
    }

    if (ctrl && key == ']')         // control-] : trace
    {
        m_owner->ptermSetTrace (!m_owner->tracePterm);
        return;
    }


#if 0
    if (ctrl && key == '\\')         // Reset Mtutor
    {
        if (m_owner->m_mtutorBoot)
        {
            m_owner->BootMtutor();
        }
        return;
    }

    if (ctrl && key == '[')         // control-[ : turn mtutor/ppt keys off
    {
        m_owner->mt_ksw &= 0xfe;
        tracex("mtutor off key");
        return;
    }
#endif

    // Special case:user has disabled Shift-Space, which means to treat
    // it as a space
    if (m_owner->m_DisableShiftSpace && key == WXK_SPACE)
    {
        shift = 0;
    }

    if (key < sizeof (asciiToPlato) / sizeof (asciiToPlato[0]))
    {
        if (ctrl && key >= 040)
        {
            // Control key is active.  There are several possibilities:
            //
            // Control plus letter: look up the translate table entry
            //  for the matching control code.
            // Control plus non-letter: look up the translate table entry
            //  for that character, and set the "shift" bit.
            // Control plus control code or function key: don't pay attention
            //  to the control key being active, and don't do a table lookup
            //  on the keycode.  Instead, those are handled later, in a switch.

#if !defined (__WXMAC__)

            // Another complication is that it may be an accelerator (if not Mac).
            // Those are handled at different spots in the event chain on
            // Windows vs. Linux.  So the only feasible way to deal with
            // them seems to be to check for them explicitly.  Note that 
            // we currently only have unshifted accelerators in Pterm.
            // Any character that is an accelerator (listed as such with the
            // ACCELERATOR macro in menu definitions) needs to be accounted
            // for in the checks below.
            if (m_owner->m_useAccel && !shift)
            {
                bool acc = false;
                
                if (m_owner->m_TutorColor && !m_owner->IgnoreKeys ())
                {
                    acc = (key >= '0' && key <= '9');
                }
                switch (key)
                {
                case 'n':
                case 's':
                case 'p':
                case 'w':
#if !defined (__WXMSW__)
                // "Quit" has its accelerator supplied automatically
                // by wxWidgets, on Unix that is.
                case 'q':
#endif
                case 'c':
                case 'v':
                case 'x':
                case 'm':
                case 'g':
                case 'u':
                    acc = true;
                }
                
                // If we conclude it's an accelerator, exit CharHook processing
                // and let the wx machinery handle it.
                if (acc)
                {
                    event.Skip ();
                    return;
                }
            }
#endif

            if (isalpha (key))
            {
                // Control letter -- do a lookup for the matching control code.
                pc = asciiToPlato[key & 037];
            }
            else
            {
                // control but not a letter or ASCII control code -- 
                // translate to what a PLATO keyboard
                // would have on the shifted position for that key
                // but only if it's a simple key (not a sequence of
                // access and other stuff)
                if (shift != 0 && key == '=')
                {
                    key = '+';
                }
                pc = asciiToPlato[key];
                if (pc != KEY1 (pc))
                {
                    // If this entry is for more than one keycode, 
                    // ignore the keystroke.
                    pc = (u32)-1;
                }
                shift = 040;
            }

            if (pc == None)
            {
                // Unknown control key, skip it
                event.Skip ();
            }
            else
            {
                m_owner->ptermSendKey (pc | shift);
            }
            return;
        }
    }

    // If we get down to this point, then the following is true:
    // 1. It wasn't an ALT-key entry.
    // 2. If Control was active, it was with a non-printable key (where we
    //    ignore the Control flag).
    // At this point, we're going to look for function keys.  If it isn't
    // one of those, then it was a regular printable character code, possibly
    // shifted.  Those are handled in the EVT_CHAR handler because the
    // unshifted to shifted translation is keyboard specific (at least for
    // non-letters) and we want to let the system deal with that.

    pc = None;
    if (m_owner->m_platoKb)
    {
#if defined (_WIN32)
        // This is a workaround for a Windows keyboard mapping bug
        if (key == '+')
        {
            pc = 0133; // =
        }
#endif
    }
    else if (m_owner->m_numpadArrows)
    {
        // Check the numeric keypad keys separately and turn them
        // into the 8-way arrow keys of the PLATO main keyboard.
        switch (key)
        {
        case WXK_NUMPAD7:
        case WXK_NUMPAD_HOME:
            pc = 0121;      // up left (q)
            break;
        case WXK_NUMPAD8:
        case WXK_NUMPAD_UP:
            pc = 0127;      // up arrow (w)
            break;
        case WXK_NUMPAD9:
        case WXK_NUMPAD_PAGEUP:
            pc = 0105;      // up right (e)
            break;
        case WXK_NUMPAD4:
        case WXK_NUMPAD_LEFT:
            pc = 0101;      // left arrow (a)
            break;
        case WXK_NUMPAD6:
        case WXK_NUMPAD_RIGHT:
            pc = 0104;      // right arrow (d)
            break;
        case WXK_NUMPAD1:
        case WXK_NUMPAD_END:
            pc = 0132;      // down left (z)
            break;
        case WXK_NUMPAD2:
        case WXK_NUMPAD_DOWN:
            pc = 0130;      // down arrow (x)
            break;
        case WXK_NUMPAD3:
        case WXK_NUMPAD_PAGEDOWN:
            pc = 0103;      // down right (c)
            break;
        }
        pc = KEY1 (pc);
    }
    
    if (pc == None)
    {
        switch (key)
        {
        case WXK_SPACE:
        case WXK_NUMPAD_SPACE:
            pc = 0100;      // space
            break;
        case WXK_BACK:
            pc = 023;       // erase
            break;
        case WXK_RETURN:
        case WXK_NUMPAD_ENTER:
            pc = 026;       // next
            break;
        case WXK_HOME:
        case WXK_NUMPAD_HOME:
        case WXK_F8:
            pc = 030;       // back
            break;
        case WXK_PAUSE:
        case WXK_F10:
            pc = 032;       // stop
            break;
        case WXK_TAB:
            pc = 014;       // tab
            break;
        case WXK_ESCAPE:
            pc = 015;       // assign
            break;
        case WXK_ADD:
        case WXK_NUMPAD_ADD:
            if (ctrl)
            {
                pc = 056;   // Sigma
            }
            else
            {
                pc = 016;   // +
            }
            break;
        case WXK_SUBTRACT:
        case WXK_NUMPAD_SUBTRACT:
            if (ctrl)
            {
                pc = 057;   // Delta
            }
            else
            {
                pc = 017;   // -
            }
            break;
        case WXK_MULTIPLY:
        case WXK_NUMPAD_MULTIPLY:
        case WXK_NUMPAD_DELETE: 
        case WXK_DELETE:
            pc = 012;       // multiply sign
            break;
        case WXK_DIVIDE:
        case WXK_NUMPAD_DIVIDE:
        case WXK_NUMPAD_INSERT: 
        case WXK_INSERT:
            pc = 013;       // divide sign
            break;
        case WXK_LEFT:
        case WXK_NUMPAD_LEFT:
            pc = 0101;      // left arrow (a)
            break;
        case WXK_RIGHT:
        case WXK_NUMPAD_RIGHT:
            pc = 0104;      // right arrow (d)
            break;
        case WXK_UP:
        case WXK_NUMPAD_UP:
            pc = 0127;      // up arrow (w)
            break;
        case WXK_DOWN:
        case WXK_NUMPAD_DOWN:
            pc = 0130;      // down arrow (x)
            break;
        case WXK_PAGEUP:
        case WXK_NUMPAD_PAGEUP:
            pc = 020;       // super
            break;
        case WXK_PAGEDOWN:
        case WXK_NUMPAD_PAGEDOWN:
            pc = 021;       // sub
            break;
        case WXK_F3:
            pc = 034;       // square
            break;
        case WXK_F2:
            pc = 022;       // ans
            break;
        case WXK_F1:
        case WXK_F11:
            pc = 033;       // copy
            break;
        case WXK_F9:
            pc = 031;       // data
            break;
        case WXK_F5:
            pc = 027;       // edit
            break;
        case WXK_F4:
            pc = 024;       // micro/font
            break;
        case WXK_F6:
            pc = 025;       // help
            break;
        case WXK_F7:
            pc = 035;       // lab
            break;
        case WXK_NUMPAD_DECIMAL:
            pc = 0136;      // .
            break;
        case WXK_NUMPAD0:
        case WXK_NUMPAD1:
        case WXK_NUMPAD2:
        case WXK_NUMPAD3:
        case WXK_NUMPAD4:
        case WXK_NUMPAD5:
        case WXK_NUMPAD6:
        case WXK_NUMPAD7:
        case WXK_NUMPAD8:
        case WXK_NUMPAD9:
            pc = key - WXK_NUMPAD0;
            if (ctrl)
            {
                shift = 040;
            }
            break;
        default:
            // If it's not a function key, we'll let the OnChar handler
            // deal with it if we are using a regular keyboard.
            // But if we're using a PLATO keyboard, we'll take the
            // (unshifted) keycode, translate it to the PLATO code, apply
            // shift if any, and send that.  This is because the 
            // shifted non-letters on the PLATO keyboard are generally
            // different from those on the PC/Mac keyboard.
            if (key >= sizeof (asciiToPlato) / sizeof (asciiToPlato[0]))
            {
                return;
            }
            pc = asciiToPlato[key];
            if (!m_owner->m_platoKb || pc == None)
            {
                event.Skip ();
                return;
            }
            // On Linux (wx/GTK), there's a keyboard handling error:
            // shifted comma key produces an OnCharHook event with 
            // key = '<', which is wrong, it should be the unshifted 
            // code.  All other codes appear to be correct, and it also
            // works right on other platforms.  Weird...  Work around
            // this by forcing the keycode.
            if (key == '<')
            {
                pc = asciiToPlato[(u8) ','];
            }
        }
        pc = KEY1 (pc);
    }

    m_owner->ptermSendKey (pc | shift);
}

void PtermCanvas::OnChar (wxKeyEvent& event)
{
    unsigned int key;
    u32 pc = None;

#if 0
    tracex ("onchar: ctrl %d shift %d alt %d keycode %d",
            event.RawControlDown (), event.ShiftDown (),
            event.AltDown (), event.GetKeyCode ());
#endif

    // control and alt codes shouldn't come here, they are handled in OnCharHook
    if (m_owner->IgnoreKeys () || event.ControlDown () ||
        event.RawControlDown () || event.AltDown ())
    {
        event.Skip ();
        return;
    }
    key = event.GetKeyCode ();

    //see if we can ignore the caplock
    if (m_owner->m_ignoreCapLock && isalpha (key) &&
        wxGetKeyState (WXK_CAPITAL))
    {
        if (wxGetKeyState (WXK_SHIFT))
        {
            key = toupper (key);
        }
        else
        {
            key = tolower (key);
        }
    }

    if (key < sizeof (asciiToPlato) / sizeof (asciiToPlato[0]))
    {
        pc = asciiToPlato[key];
        if (pc != None)
        {
            m_owner->ptermSendKey (pc);
            return;
        }
    }
    event.Skip ();
}

void PtermCanvas::OnMouseWheel (wxMouseEvent &event)
{
    int key = event.m_wheelRotation;
    m_owner->ptermSendExt ((key>0 ? ~1 : 1) & 0xff);
    event.Skip ();
}

void PtermCanvas::OnMouseDown (wxMouseEvent &event)
{
    Unadjust (event.m_x, event.m_y, &m_mouseX, &m_mouseY);
    m_owner->ClearRegion ();
    event.Skip ();
}

void PtermCanvas::OnMouseMotion (wxMouseEvent &event)
{
    int xx, yy;
    
    if (m_mouseX >= 0 && event.m_leftDown)
    {
        Unadjust (event.m_x, event.m_y, &xx, &yy);
        m_owner->UpdateRegion (xx, yy, m_mouseX, m_mouseY);
    }
    
    event.Skip ();
}

void PtermCanvas::OnMouseContextMenu (wxMouseEvent &)
{
    m_owner->PopupMenu (m_owner->menuPopup);
}

void PtermCanvas::OnMouseUp (wxMouseEvent &event)
{
    int x, y;
    
    if (m_mouseX < 0)
    {
        event.Skip ();
        return;
    }

    Unadjust (event.m_x, event.m_y, &x, &y);

    m_owner->UpdateRegion (x, y, m_mouseX, m_mouseY);

    m_mouseX = -1;

    if (!m_touchEnabled)
    {
        return;
    }
    if (x < 0 || x > 511 ||
        y < 0 || y > 511)
    {
        return;
    }
    m_owner->ptermSendTouch (x, y);

}

void PtermCanvas::ptermTouchPanel (bool enable)
{
    m_touchEnabled = enable;
    if (enable)
    {
        SetCursor (wxCursor (wxCURSOR_HAND));
    }
    else
    {
        SetCursor (wxNullCursor);
    }
}

#if defined (__WXMSW__)
// Override the window proc to avoid F10 being handled  as a hotkey
WXLRESULT PtermCanvas::MSWWindowProc (WXUINT message, WXWPARAM wParam,
                                      WXLPARAM lParam)
{
    if (message == WM_SYSKEYDOWN && wParam == VK_F10)
    { 
        m_lastKeydownProcessed = HandleKeyDown ((WORD) wParam, lParam);
        return 0;
    }
    return wxScrolledCanvas::MSWWindowProc (message, wParam, lParam);
}
#endif


#if PTERM_MDI

DummyProf dummyProf = { true };

// MDI parent frame
PtermMainFrame::PtermMainFrame (void)
    : wxMDIParentFrame (NULL, wxID_ANY, wxT ("Pterm"),
                        wxPoint (1, 1), wxSize (1, 1), 0)
{
    // PLEASE NOTE:
    // On non-Mac platforms, accelerators are control keys.  These
    // may conflict with the use of control keys for PLATO function
    // keys.  The conflict is sorted out in an explicit check for
    // accelerator keys in function OnCharHook.  If you change which
    // characters are accelerators, you must update the code in that
    // function.
    m_profile = &dummyProf;
    menuFile = new wxMenu;
    menuFile->Append (Pterm_Connect,
                      _("New Terminal Window...") ACCELERATOR ("\tCtrl-N"),
                      _("Connect to a PLATO host"));
    menuFile->Append (Pterm_Pref,
                      _("Preferences...") MACACCEL ("\tCtrl-,"),
                      _("Set program configuration"));
    menuFile->AppendSeparator ();
    menuFile->Append (Pterm_Quit, _("Exit"), _("Quit this program"));

    // the "About" item should be in the help menu.
    // Well, on the Mac it actually doesn't show up there, but for that magic
    // to work it has to be presented to wx in the help menu.  So the help
    // menu ends up empty.  Sigh.
    menuHelp = new wxMenu;

    menuHelp->Append (Pterm_About, _("About Pterm"), _("Show about dialog"));
    menuHelp->Append (Pterm_HelpKeys, _("Pterm keyboard"),
                      _("Show keyboard description"));
    menuHelp->Append (Pterm_HelpIndex, _("Pterm help"),
                      _("Show Pterm help index"));
    
    // now append the freshly created menu to the menu bar...
    menuBar = new wxMenuBar ();
    menuBar->Append (menuFile, _("File"));
    menuBar->Append (menuHelp, _("Help"));

    // ... and attach this menu bar to the frame
#if !defined (__WXMAC__)
    if (!m_fullScreen && m_owner->m_showMenuBar)
#endif
        SetMenuBar (menuBar);
}
#endif

// ----------------------------------------------------------------------------
// main frame
// ----------------------------------------------------------------------------


const PtermFrame::mptr PtermFrame::modePtr[8] =
{
    &PtermFrame::mode0, &PtermFrame::mode1,
    &PtermFrame::mode2, &PtermFrame::mode3,
    &PtermFrame::mode4, &PtermFrame::mode5,
    &PtermFrame::mode6, &PtermFrame::mode7
};



// frame constructor
PtermFrame::PtermFrame (const wxString& title, PtermProfile *profile,
                        PtermConnection *conn, bool helpframe)
    : PtermFrameBase (PtermFrameParent, -1, title,
                      ForceValidStartPoint (profile->m_restoreX, profile->m_restoreY),
                      wxDefaultSize),
      m_profile (profile),
      m_helpframe (helpframe),
      tracePterm (false),
      m_currentWord (0),
      m_nextFrame (NULL),
      m_prevFrame (NULL),
      m_pendingEcho (-1),
      m_bCancelPaste (false),
      m_bPasteActive (false),
      m_conn (conn),
      m_dumbTty (true),
      m_statusBar (NULL),
      m_scale (profile->m_scale),
      m_fullScreen (false),
      m_xscale (m_scale <= 0 ? 1 : m_scale),
      m_yscale (m_scale <= 0 ? 1 : m_scale),
      m_usefont (false),
      m_fontPMD (false),
      m_fontinfo (false),
      m_osinfo (false),
      m_gswFFmt (0),
      m_canvas (NULL),
      m_station (""),
      m_timer (this, Pterm_Timer),
      m_Mclock(this, Pterm_Mclock),
      m_Dclock(this, Pterm_Dclock),
      m_MReturnz80(this, Pterm_Mz80),
      m_mtincnt (0),
      m_mtdrivetemp (0xcb),
      m_mtdrivefunc (0),
      m_clockPhase (true),
      m_name (""),
      m_group (""),
      m_system (""),
      m_pasteTimer (this, Pterm_PasteTimer),
      m_pasteIndex (-1),
      m_nextword (C_NODATA),
      m_delay (0),
      mt_key (-1),
      modexor (false),
      currentX (0),
      currentY (496),
      memaddr (0),
      memlpc (0),
      wc (0),
      seq (0),
      modewords (0),
      m_ascState (none),
      m_ascBytes (0),
      lastX (0),
      lastY (0),
      m_flowCtrl (false),
      m_sendFgt (false),
      m_defFg (profile->m_fgColor),
      m_defBg (profile->m_bgColor),
      m_currentFg (profile->m_fgColor),
      m_currentBg (profile->m_bgColor),
      m_loadingPMD (false),
      cwsmode (0),
      cwsfun (0),
      cwscnt (0),
      cwswin (0),
      m_regionX (0),
      m_regionY (0),
      m_regionHeight (0),
      m_regionWidth (0)
{
    int i;

    conn->SetOwner (this);
  
    mode = 017;             // default to character mode, rewrite

    mt_ksw = 0;             // route input to terminal
    mt_key = -1;
    mjobs = 0;

    modexor = false;
    setMargin (0);
    RAM[M_CCR] = 0;
    RAM[M_TYPE] = 0x3c;

    m_classicSpeed = profile->m_classicSpeed;
    m_gswEnable = profile->m_gswEnable;
    m_numpadArrows = profile->m_numpadArrows;
    m_ignoreCapLock = profile->m_ignoreCapLock;
    m_platoKb = profile->m_platoKb;
    m_useAccel = profile->m_useAccel;
    m_beepEnable = profile->m_beepEnable;
    m_DisableShiftSpace = profile->m_DisableShiftSpace;
    m_DisableMouseDrag = profile->m_DisableMouseDrag;
    //tab4
//#define SCALE_ASPECT  0.    // Scale to window, square aspect ratio
//#define SCALE_FREE   -1.    // Scale to window, free form
    m_showStatusBar = profile->m_showStatusBar;
    m_FancyScaling = profile->m_FancyScaling;
#if !defined (__WXMAC__)
    m_showMenuBar = profile->m_showMenuBar;
#endif
    m_noColor = profile->m_noColor;
    m_fgColor = profile->m_fgColor;
    m_bgColor = profile->m_bgColor;

    //tab5
    m_charDelay = profile->m_charDelay;
    m_lineDelay = profile->m_lineDelay;
    m_autoLF = profile->m_autoLF;
    m_smartPaste = profile->m_smartPaste;
    m_convDot7 = profile->m_convDot7;
    m_conv8Sp = profile->m_conv8Sp;
    m_TutorColor = profile->m_TutorColor;
    m_trimEnd = profile->m_trimEnd;
    //tab6
    m_SearchURL = profile->m_SearchURL;

    m_mtutorBoot = profile->m_mTutorBoot;
    m_floppy0 = profile->m_floppy0;
    m_floppy1 = profile->m_floppy1;
    m_floppy0File = profile->m_floppy0File;
    m_floppy1File = profile->m_floppy1File;

    if (m_floppy0 && m_floppy0File.Length() > 0)
        m_MTFiles[0].Open(m_floppy0File);
    else
        m_MTFiles[0].Close();

    if (m_floppy1 && m_floppy1File.Length() > 0)
        m_MTFiles[1].Open(m_floppy1File);
    else
        m_MTFiles[1].Close();

    // Set default character set origins (for PPT that is; ASCII is different)
    RAM[C2ORIGIN] = M2ADDR & 0xff;
    RAM[C2ORIGIN + 1] = M2ADDR >> 8;
    RAM[C3ORIGIN] = M3ADDR & 0xff;
    RAM[C3ORIGIN + 1] = M3ADDR >> 8;
    
    // set the frame icon
    SetIcon (wxICON (pterm_32));


    // create a menu bar
    BuildMenuBar ();

    // Build the popup menu
    BuildPopupMenu ();

    // If we're supposed to run a shell program, do so; then wait 2 seconds
    if (!profile->m_ShellFirst.IsEmpty ())
    {
        if (wxExecute (profile->m_ShellFirst)!=0)
        {
#if defined (_WIN32)
            Sleep (2000);
#else
            sleep (2);
#endif
        }
    }
    SetCursor (*wxHOURGLASS_CURSOR);
    
    // Build status bar if we want it
    BuildStatusBar ();

    m_bitmap = new wxBitmap (512, 512, 32);
    {
        PixelData pixmap (*m_bitmap);

        if (!pixmap)
        {
            // ... raw access to bitmap data unavailable, do something else ...
            printf ("no raw bitmap access\n");
            exit (1);
        }

        // Find out how RGBA map to the parts of a 32 bit value, so we can
        // access things as 32 bit arrays and still be implementation
        // independent.
        PixelData::Iterator p (pixmap);
        u32 *pmap = (u32 *) (p.m_ptr);
        u8 *pb = (u8 *) pmap;
        u32 t;
    
        t = *pmap;
        *pmap = 0;
        p.Alpha () = 255;
        m_maxalpha = *pmap;
        *pmap = 0;
        p.Red () = 1;
        for (i = 0; i < 4; i++)
        {
            if (pb[i]) m_red = i;
        }
        *pmap = 0;
        p.Green () = 1;
        for (i = 0; i < 4; i++)
        {
            if (pb[i]) m_green = i;
        }
        *pmap = 0;
        p.Blue () = 1;
        for (i = 0; i < 4; i++)
        {
            if (pb[i]) m_blue = i;
        }
        // Pixel value for selected text is white on 
        // translucent gray background, except on Windows
        // because it doesn't support Alpha (though that
        // seems to be undocumented).  So there we use
        // black foreground on medium gray background.
#if defined (__WXMSW__)
        p.Alpha () = 255;
        p.Red () = p.Green () = p.Blue () = 0;
        m_selpixf = *pmap;
        p.Red () = p.Green () = p.Blue () = 140;
        m_selpixb = *pmap;
#else
        p.Alpha () = 255;
        p.Red () = p.Green () = p.Blue () = 255;
        m_selpixf = *pmap;
        p.Alpha () = 140;
        m_selpixb = *pmap;
#endif
        *pmap = t;
    }
    m_memDC = new wxMemoryDC ();
    m_selmap = new wxBitmap (512, 512, 32);
    // for 2x scalling for Retina display, if active
    m_bitmap2 = new wxBitmap (512 * 2, 512 * 2, 32);
    m_canvas = new PtermCanvas (this);

    SetColors (m_currentFg, m_currentBg);    
    SetClientSize (XSize, YSize);
    ptermFullErase ();
    UpdateDisplayState ();

    // If it's not the help frame, link it into the list of frames
    if (!helpframe)
    {
        if (ptermApp->m_firstFrame != NULL)
        {
            ptermApp->m_firstFrame->m_prevFrame = this;
        }
        m_nextFrame = ptermApp->m_firstFrame;
        ptermApp->m_firstFrame = this;
    }
    conn->Connect ();
    m_needtoBoot = false;

    if (m_mtutorBoot)
        m_needtoBoot = true;

    Show (true);

}

wxPoint PtermFrame::ForceValidStartPoint (long prefX, long prefY)
{
    int dspi, sz;

    // Pick up the preferred x/y (saved from last time).  Adjust these
    // to make sure that the top left corner of the window is on screen,
    // and second (if possible) that the whole window is.
    debug ("saved x/y is %ld, %ld", prefX, prefY);
    dspi = wxDisplay::GetFromPoint (wxPoint (prefX, prefY));
    if (dspi == wxNOT_FOUND)
    {
        dspi = 0;
    }

    wxDisplay dsp (dspi);
    wxRect ca = dsp.GetClientArea ();

    debug ("display %d client area pos %d, %d size %d, %d",
        dspi, ca.x, ca.y, ca.width, ca.height);

    // Adjust to make the bottom right corner be on-screen
    sz = 512 + 2 * DisplayMargin;
#if 0
    if (m_scale > 0.)
    {
        sz *= m_scale;
    }
#endif
    prefX += sz;
    prefY += sz;
    // width and height have some adjustment added to it to allow for
    // window decoration.  
    if (prefX > ca.x + ca.width - 5)
    {
        prefX = ca.x + ca.width - 5;
    }
    if (prefY > ca.y + ca.height - 25)
    {
        prefY = ca.y + ca.height - 25;
    }
    // From the adjusted bottom right, get the adjusted top left
    prefX -= sz;
    prefY -= sz;
    if (prefX < ca.x)
    {
        prefX = ca.x;
    }
    if (prefY < ca.y)
    {
        prefY = ca.y;
    }
    debug ("adjusted x/y is %ld, %ld", prefX, prefY);

    return wxPoint (prefX, prefY);
}


void PtermFrame::trace (const wxString &msg) const
{
    wxString hdr;
    
    if (traceF.Active ())
    {
        hdr.Printf ("%07o seq %6d wc %3d ", m_currentWord, seq, wc);
        hdr.Append (msg);
        traceF.Log (hdr);
    }
}

void PtermFrame::trace (const char *fmt, ...) const
{
    va_list v;
    wxString msg;
    
    if (traceF.Active ())
    {
        va_start (v, fmt);
        msg.PrintfV (fmt, v);
        va_end (v);
        trace (msg);
    }
}

PtermFrame::~PtermFrame ()
{
    if (m_conn != NULL)
    {
        delete m_conn;
        m_conn = NULL;
    }
    delete m_bitmap;
    if (m_bitmap2 != NULL)
    {
        delete m_bitmap2;
    }
    delete m_selmap;
    delete m_memDC;
    m_bitmap = m_bitmap2 = m_selmap = NULL;
    m_memDC = NULL;

    // If this is the help frame, remember we no longer have it
    if (this == ptermApp->m_helpFrame)
    {
        ptermApp->m_helpFrame = NULL;
    }

    // Remove this frame from the app's frame list
    if (m_nextFrame != NULL)
    {
        m_nextFrame->m_prevFrame = m_prevFrame;
    }
    if (m_prevFrame != NULL)
    {
        m_prevFrame->m_nextFrame = m_nextFrame;
    }
    else
    {
        ptermApp->m_firstFrame = m_nextFrame;
    }
    ptermApp->TestForExit ();
}

void PtermFrame::BuildMenuBar (void)
{
    menuBar = new wxMenuBar ();

    // First build the menus:
    // File menu options
    BuildFileMenu ();

    //edit menu options
    BuildEditMenu ();

    //view menu options
    menuView = new wxMenu;
    BuildViewMenu (menuView);

    //help menu options
    BuildHelpMenu ();
    
    // Now put them on the bar
    menuBar->Append (menuFile, _("File"));
    menuBar->Append (menuEdit, _("Edit"));
    menuBar->Append (menuView, _("View"));
    menuBar->Append (menuHelp, _("Help"));

#if !defined (__WXMAC__)
    if (!m_fullScreen && m_showMenuBar)
#endif
        SetMenuBar (menuBar);
}

// NOTE: Accelerators are actually Command-xxx on the Mac
// on other platforms they are controlled by a prefs setting.

void PtermFrame::BuildFileMenu (void)
{
    ConnType_e ct = m_conn->ConnType ();
    menuFile = new wxMenu;
    menuFile->Append (Pterm_Connect,
                      _("New Terminal Window...") ACCELERATOR ("\tCtrl-N"),
                      _("New Terminal Window"));

    if (m_mtutorBoot)
    {
        menuFile->Append(Pterm_ResetMtutor, _("Reset MicroTutor"),
                         _("Reset the MicroTutor boot process") );
    }
    else if (ct == HOST)
    {
        // "Connect Again" only for the host window because other
        // types don't own a connection.
        menuFile->Append (Pterm_ConnectAgain,
                          _("Connect Again") ACCELERATOR ("\tCtrl-Shift-N"),
                          _("Connect to the same host"));
    }
    menuFile->AppendSeparator();

    menuFile->Append (Pterm_SaveScreen,
                      _("Save Screen") ACCELERATOR ("\tCtrl-S"),
                      _("Save screen image to file"));
    if (ct == HOST) // || ct == LOCAL ?
    {
        // Save audio is disabled until we know that we have a classic connection
        menuFile->Append (Pterm_SaveAudio, _("Save GSW Audio"),
                          _("Save GSW sound to audio file"));
        menuFile->Enable (Pterm_SaveAudio, false);
    }
    menuFile->Append (Pterm_Print,
                      _("Print...") ACCELERATOR ("\tCtrl-P"),
                      _("Print screen content"));
    menuFile->Append (Pterm_Page_Setup, _("Page Setup..."),
                      _("Printout page setup"));
    menuFile->Append (Pterm_Preview, _("Print Preview"),
                      _("Preview screen print"));
    menuFile->AppendSeparator ();
    menuFile->Append (Pterm_Pref, _("Edit Profiles...")
                      MACACCEL ("\tCtrl-,"),
                      _("Set program configuration"));
    if (!m_profile->m_isHelp)
    {
        menuFile->Append(Pterm_SessionSettings,
                         _("Session Settings..."),
                         _("Set the session settings"));
    }
#if defined (__WXMAC__)
    if (ct == HOST || ct == LOCAL)
#endif
        menuFile->AppendSeparator ();
    menuFile->Append (Pterm_Close,
                      _("Close") ACCELERATOR ("\tCtrl-W"),
                      _("Close this window"));
    menuFile->Append (Pterm_Quit, _("Exit"), _("Quit this program"));
}

void PtermFrame::BuildEditMenu (void)
{
    ConnType_e ct = m_conn->ConnType ();
    
    menuEdit = new wxMenu;
    menuEdit->Append (Pterm_CopyScreen, _("Copy Screen"),
                      _("Copy screen to clipboard"));
    menuEdit->Append (Pterm_Copy,
                      _("Copy text") ACCELERATOR ("\tCtrl-C"),
                      _("Copy text only to clipboard"));
    if (ct == HOST || ct == LOCAL)
    {
        menuEdit->Append (Pterm_Paste,
                          _("Paste plain text") ACCELERATOR ("\tCtrl-V"),
                          _("Paste plain text"));
        menuEdit->Append (Pterm_PastePrint, _("Paste Printout"),
                          _("Paste Cyber printout format"));
    }
    menuEdit->AppendSeparator ();                   
    menuEdit->Append (Pterm_Exec,
                      _("Execute URL") ACCELERATOR ("\tCtrl-X"),
                      _("Execute URL"));
    menuEdit->Append (Pterm_MailTo,
                      _("Mail to...") ACCELERATOR ("\tCtrl-M"),
                      _("Mail to..."));
    menuEdit->Append (Pterm_SearchThis,
                      _("Search this...") ACCELERATOR ("\tCtrl-G"),
                      _("Search this...")); // g=google this?
    if (m_TutorColor && (ct == HOST || ct == LOCAL))
    {
        menuEdit->AppendSeparator ();
        menuEdit->Append (Pterm_Macro0,
                          wxT ("Box 8x") ACCELERATOR ("\tCtrl-0"),
                          wxT ("Box 8x"));
        menuEdit->Append (Pterm_Macro1,
                          wxT ("<c,zc.errf>") ACCELERATOR ("\tCtrl-1"),
                          wxT ("<c,zc.errf>"));
        menuEdit->Append (Pterm_Macro2,
                          wxT ("<c,zc.info>") ACCELERATOR ("\tCtrl-2"),
                          wxT ("<c,zc.info>"));
        menuEdit->Append (Pterm_Macro3,
                          wxT ("<c,zc.keys>") ACCELERATOR ("\tCtrl-3"),
                          wxT ("<c,zc.keys>"));
        menuEdit->Append (Pterm_Macro4,
                          wxT ("<c,zc.text>") ACCELERATOR ("\tCtrl-4"),
                          wxT ("<c,zc.text>"));
        menuEdit->Append (Pterm_Macro5,
                          wxT ("color zc.errf") ACCELERATOR ("\tCtrl-5"),
                          wxT ("color zc.errf"));
        menuEdit->Append (Pterm_Macro6,
                          wxT ("color zc.info") ACCELERATOR ("\tCtrl-6"),
                          wxT ("color zc.info"));
        menuEdit->Append (Pterm_Macro7,
                          wxT ("color zc.keys") ACCELERATOR ("\tCtrl-7"),
                          wxT ("color zc.keys"));
        menuEdit->Append (Pterm_Macro8,
                          wxT ("color zc.text") ACCELERATOR ("\tCtrl-8"),
                          wxT ("color zc.text"));
        menuEdit->Append (Pterm_Macro9,
                          wxT ("Menu colorization") ACCELERATOR ("\tCtrl-9"),
                          wxT ("Menu colorization"));
    }
    // screen-region related options are disabled until a region is selected
    menuEdit->Enable (Pterm_Copy, false);
    menuEdit->Enable (Pterm_Exec, false);
    menuEdit->Enable (Pterm_MailTo, false);
    menuEdit->Enable (Pterm_SearchThis, false);
}

void PtermFrame::BuildViewMenu (wxMenu *menu)
{
    int i;
    wxString fmt;
    const double *sl;
    
#if !defined (__WXMAC__)
    menu->AppendCheckItem (Pterm_ToggleMenuBar,
                           _("Display menu bar"), _("Display menu bar"));
    menu->Check (Pterm_ToggleMenuBar, m_showMenuBar);
#endif
    if (!m_profile->m_isHelp)
    {
        menu->AppendCheckItem (Pterm_ToggleStatusBar,
                               _("Display status bar"),
                               _("Display status bar"));
        menu->Check (Pterm_ToggleStatusBar, m_showStatusBar);
    }
    menu->AppendSeparator ();

    menu->Append (Pterm_ToggleLock,
        !m_profile->m_lockPosition ? _ ("Save location now") : 
            _ ("Save location on close"),
        !m_profile->m_lockPosition ? _ ("Save window location now") : 
            _ ("Save window location on close"));

    menu->Append (Pterm_RestoreLocation,
        _ ("Restore Location"),
        _ ("Restore window location"));


    menu->AppendSeparator ();

    if (GetContentScaleFactor () == 2.0)
    {
        scaleList = scaleList_Retina;
        fmt = _("Zoom display %1.1fx");
    }
    else
    {
        scaleList = scaleList_std;
        fmt = _("Zoom display %1.0fx");
    }
    for (sl = scaleList; *sl > 0.; sl++)
    {
        wxString lb;
        
        i = sl - scaleList;
        lb.Printf (fmt, *sl);
        menu->AppendRadioItem (Pterm_SetScaleEntry + i, lb, lb);
        // Bind the handler
        Bind (wxEVT_COMMAND_MENU_SELECTED, &PtermFrame::OnSetScaleEntry, 
              this, Pterm_SetScaleEntry + i);
        if (scaleList[i] == m_profile->m_scale)
        {
            menu->Check (Pterm_SetScaleEntry + i, true);
        }
    }
    menu->AppendRadioItem (Pterm_ToggleStretchMode,
                           _("Stretch display"), _("Stretch display"));
    if (m_profile->m_scale == SCALE_FREE)
    {
        menu->Check (Pterm_ToggleStretchMode, true);
    }
    menu->AppendRadioItem (Pterm_ToggleAspectMode,
                           _("Keep aspect ratio"), _("Keep aspect ratio"));
    if (m_profile->m_scale == SCALE_ASPECT)
    {
        menu->Check (Pterm_ToggleAspectMode, true);
    }
    menu->AppendSeparator ();
    menu->Append (Pterm_FullScreen, _("Full Screen")
                  ACCELERATOR ("\tCtrl-U"),
                  _("Display in full screen mode"));
}

void PtermFrame::BuildHelpMenu (void)
{
    // the "About" item should be in the help menu.
    // Well, on the Mac it actually doesn't show up there, but for that magic
    // to work it has to be presented to wx in the help menu.  So the help
    // menu ends up empty.  Sigh.
    menuHelp = new wxMenu;
    menuHelp->Append (Pterm_About, _("About Pterm"), _("Show about dialog"));
    menuHelp->Append (Pterm_HelpKeys, _("Pterm keyboard"),
                      _("Show keyboard description"));
    menuHelp->Append (Pterm_HelpIndex, _("Pterm help"),
                      _("Show Pterm help index"));
}

void PtermFrame::BuildPopupMenu (void)
{
    ConnType_e ct = m_conn->ConnType ();

    menuPopup = new wxMenu;
    menuPopup->Append (Pterm_CopyScreen, _("Copy Screen"),
                       _("Copy screen to clipboard"));
    menuPopup->Append (Pterm_Copy, _("Copy text") ACCELERATOR ("\tCtrl-C"),
                       _("Copy text only to clipboard"));
    if (ct == HOST || ct == LOCAL)
    {
        menuPopup->Append (Pterm_Paste, _("Paste ASCII")
                           ACCELERATOR ("\tCtrl-V"), _("Paste plain text"));
        menuPopup->Append (Pterm_PastePrint, _("Paste Printout"),
                           _("Paste Cyber printout format"));
    }
    menuPopup->AppendSeparator ();                  
    menuPopup->Append (Pterm_Exec, _("Execute URL") ACCELERATOR ("\tCtrl-X"),
                       _("Execute URL"));
    menuPopup->Append (Pterm_MailTo, _("Mail to...") ACCELERATOR ("\tCtrl-M"),
                       _("Mail to..."));
    menuPopup->Append (Pterm_SearchThis, _("Search this...")
                       ACCELERATOR ("\tCtrl-G"),
                       _("Search this...")); // g=google this?
    menuPopup->AppendSeparator ();

    if (!m_profile->m_isHelp)
    {
        menuPopup->Append(Pterm_SessionSettings,
                          _("Session Settings..."),
                          _("Set the session settings"));
        menuPopup->AppendSeparator();
    }
    
    // The view menu stuff also appears in the popup.
    BuildViewMenu (menuPopup);
    if (m_TutorColor && (ct == HOST || ct == LOCAL))
    {
        menuPopup->AppendSeparator ();
        menuPopup->Append (Pterm_Macro0, wxT ("Box 8x")
                           ACCELERATOR ("\tCtrl-0"), wxT ("Box 8x"));
        menuPopup->Append (Pterm_Macro1, wxT ("<c,zc.errf>")
                           ACCELERATOR ("\tCtrl-1"), wxT ("<c,zc.errf>"));
        menuPopup->Append (Pterm_Macro2, wxT ("<c,zc.info>")
                           ACCELERATOR ("\tCtrl-2"), wxT ("<c,zc.info>"));
        menuPopup->Append (Pterm_Macro3, wxT ("<c,zc.keys>")
                           ACCELERATOR ("\tCtrl-3"), wxT ("<c,zc.keys>"));
        menuPopup->Append (Pterm_Macro4, wxT ("<c,zc.text>")
                           ACCELERATOR ("\tCtrl-4"), wxT ("<c,zc.text>"));
        menuPopup->Append (Pterm_Macro5, wxT ("color zc.errf")
                           ACCELERATOR ("\tCtrl-5"), wxT ("color zc.errf"));
        menuPopup->Append (Pterm_Macro6, wxT ("color zc.info")
                           ACCELERATOR ("\tCtrl-6"), wxT ("color zc.info"));
        menuPopup->Append (Pterm_Macro7, wxT ("color zc.keys")
                           ACCELERATOR ("\tCtrl-7"), wxT ("color zc.keys"));
        menuPopup->Append (Pterm_Macro8, wxT ("color zc.text")
                           ACCELERATOR ("\tCtrl-8"), wxT ("color zc.text"));
        menuPopup->Append (Pterm_Macro9, wxT ("Menu colorization")
                           ACCELERATOR ("\tCtrl-9"), wxT ("Menu colorization"));
    }
    // screen-region related options are disabled until a region is selected
    menuPopup->Enable (Pterm_Copy, false);
    menuPopup->Enable (Pterm_Exec, false);
    menuPopup->Enable (Pterm_MailTo, false);
    menuPopup->Enable (Pterm_SearchThis, false);
}

// For some strange reason it seems to be necessary to delete 
// the statusbar (not just unlink it) if we don't want to see it.
// If it exists as an object but isn't tied to the window, it displays
// at the top of the window !
void PtermFrame::BuildStatusBar (void)
{
    const bool showstatusbar = (!m_fullScreen &&
                                m_showStatusBar &&
                                m_conn->ConnType () != HELP);
    const bool havestatusbar = (m_statusBar != NULL);
    int ww, wh, ow, oh, nw, nh;

    // get window parameters before changing things
    GetSize(&ww, &wh);
    GetClientSize (&ow, &oh);
    
    if (!showstatusbar && havestatusbar)
    {
        // We have one right now but don't want it
        SetStatusBar (NULL);
        delete m_statusBar;
        m_statusBar = NULL;
        debug ("Turning off status bar");
    }
    else if (showstatusbar && !havestatusbar)
    {
        // We don't have one, but want one
        m_statusBar = new wxStatusBar (this, wxID_ANY);
        m_statusBar->SetFieldsCount (STATUSPANES);

        if (m_mtutorBoot)
        {
            m_statusBar->SetStatusText(_(" Booted from floppy"),
                STATUS_CONN);
        }
        else if (m_conn == NULL)
        {
            m_statusBar->SetStatusText (_(" Not connected"), STATUS_CONN);
        }
        else if (!m_conn->m_connActive)
        {
            m_statusBar->SetStatusText (_(" Connecting..."), STATUS_CONN);
        }
        else
        {
            ptermSetConnected ();
        }
        ptermShowTrace ();
        SetStatusBar (m_statusBar);
        debug ("Turning on status bar");
    }

    //check if size changed
    GetClientSize (&nw, &nh);
    SetSize (ww, wh - (nh - oh));
}

// event handlers

void PtermFrame::OnIdle (wxIdleEvent& event)
{
    // In every case, let others see this event too.
    event.Skip ();

    if (m_needtoBoot)
    {
        m_needtoBoot = false;
        BootMtutor();
    }

    // Do nothing for the help window.
    // If our timer is running, we're using the timer event to drive
    // the display, so ignore idle events.
    if (IgnoreKeys() || m_timer.IsRunning ())
    {
        return;
    }

    if ( ppt_running && !in_r_exec )
    {
        SaveRestoreColors (save, host);
        SaveRestoreColors (restore, micro);
        MicroEmulate;
        SaveRestoreColors (save, micro);
        SaveRestoreColors (restore, host);
        return;
    }

    procDataLoop ();

    if (m_MReturnz80.IsRunning())
    {
        m_MReturnz80.Stop();
        SaveRestoreColors (save, host);
        SaveRestoreColors (restore, micro);
        MicroEmulate;
        SaveRestoreColors (save, micro);
        SaveRestoreColors (restore, host);
    }
}

void PtermFrame::OnTimer (wxTimerEvent &)
{
    if (m_needtoBoot)
    {
        m_needtoBoot = false;
        BootMtutor();
    }

    if (--m_delay > 0)
    {
        return;
    }

    if (ppt_running && !in_r_exec)
    {
        SaveRestoreColors (save, host);
        SaveRestoreColors (restore, micro);
        MicroEmulate;
        SaveRestoreColors (save, micro);
        SaveRestoreColors (restore, host);
        return;
    }

    m_timer.Stop ();

    procDataLoop ();

    if (m_MReturnz80.IsRunning())
    {
        m_MReturnz80.Stop();
        SaveRestoreColors (save, host);
        SaveRestoreColors (restore, micro);
        MicroEmulate;
        SaveRestoreColors (save, micro);
        SaveRestoreColors (restore, host);
    }
}

// ppt m.clock
void PtermFrame::OnMclock(wxTimerEvent &)
{
    u16 temp = ReadRAMW(M_CLOCK);
    WriteRAMW(M_CLOCK, ++temp);
    ptermShowTrace ();
    if ((temp % 6) == 0)
    {
        m_MTFiles[0].rwflag = wxT ("  ");
        m_MTFiles[1].rwflag = wxT ("  ");
    }
}
// ppt d.clock
void PtermFrame::OnDclock(wxTimerEvent &)
{
    m_zclock++;
}


// resume z80 execution after it gives up control to resident
void PtermFrame::OnMz80(wxTimerEvent &)
{
    SaveRestoreColors (save, host);
    SaveRestoreColors (restore, micro);
    MicroEmulate;
    SaveRestoreColors (save, micro);
    SaveRestoreColors (restore, host);
}


// Common code for processing pending PLATO data.  This is used by the
// OnIdle handler for the normal (no delay, no pacing) case, and by
// the OnTimer handler if delay is currently being done.
void PtermFrame::procDataLoop (void)
{
    int word = 0;   // Initialize to prevent randomness below
    bool refresh = false;
    
    mjobs = 0;

    if (m_nextword != C_NODATA)
    {
        m_ignoreDelay = false;      // Assume it's not block erase
        refresh = procPlatoWord (m_nextword, m_conn->Ascii ());
        m_nextword = C_NODATA;
    }

    // If in local mode (booted from floppy) we never process input
    // because we don't have a connection at all.
    while (!m_mtutorBoot)
    {
        /*
        **  Process words until there is nothing left.
        */
        word = m_conn->NextWord ();
    
        if (word == C_NODATA || word == C_DISCONNECT ||
            word == C_CONNFAIL1 || word == C_CONNFAIL2)
        {
            break;
        }

        // See if we're supposed to delay (but it's not an internal
        // code such as NODATA)
        if ((int) word >= 0 && (word >> 19) != 0)
        {
            if (m_ignoreDelay && 
                (word == 02000000 || (word == 02000001 && !m_conn->Ascii ())))
            {
                // Ignore Delay is set (since previous operation
                // was block erase) and this is a NOP word.  If so,
                // just ignore it, don't do any delay.
                continue;
            }
            
            m_delay = word >> 19;
            m_nextword = word & 01777777;
            if (m_conn->Ascii ())
            {
                m_timer.Start (8);  // 16.67 / (21 / 10), rounded
            }
            else
            {
                m_timer.Start (17);
            }
            
            if (refresh)
            {
                m_canvas->Refresh (false);
            }

            return;
        }
        
        debug ("processing data from plato %07o", word);
        m_ignoreDelay = false;      // Assume it's not block erase
        refresh |= procPlatoWord (word, m_conn->Ascii ());
    }

    if (refresh)
    {
        m_canvas->Refresh (false);
    }
    
    // must check m_mtutorBoot else word has not been initialized.
    if (!m_mtutorBoot && (word == C_DISCONNECT ||
                          word == C_CONNFAIL2 ||
                          word == C_CONNFAIL2))
    {
        wxString msg;

        // Report the problem
        if (m_statusBar != NULL)
        {
            m_statusBar->SetStatusText (_(" Not connected"),
                                        STATUS_CONN);
        }

        wxDateTime ldt;

        ldt.SetToCurrent ();
        if (word == C_CONNFAIL1 || word == C_CONNFAIL2)
        {
            msg.Printf (_("Connection failed @ %s on "),
                        ldt.FormatTime ());
        }
        else
        {
            msg.Printf (_("Dropped connection @ %s on "),
                        ldt.FormatTime ());
        }
        msg.Append (ldt.FormatDate ());
        WriteTraceMessage (msg);
        msg.Printf (_("%s on "), ldt.FormatTime ());
        msg.Append (ldt.FormatDate ());   // fits in dialog box title
        
        Iconize (false);    // make window visible when connection fails

        PtermConnFailDialog dlg (wxID_ANY, msg, wxDefaultPosition,
                                 wxSize (320, 140), word, m_profile);
        dlg.CenterOnScreen ();

        int action = dlg.ShowModal ();
        
        switch (action)
        {
        case wxID_OK:
            // ???
            ptermApp->DoConnectDialog ();
            break;
        default:
            Close (true);
        }
    }
}

// This method is invoked by the paste character pacing timer, once
// for each character to be pasted.  It sends the key code(s) for
// the character and re-arms the timer, if more needs to be done.
void PtermFrame::OnPasteTimer (wxTimerEvent &)
{
    wxChar c = 0, c2 = 0;
    u32 p;
    int pp, i, nextindex, nextpos;
    int delay = 0;
    bool dot7 = false;

    if (m_bCancelPaste || m_pasteIndex < 0 || m_pasteIndex >= m_pasteLen)
    {
        //reset flags
        m_bCancelPaste = false;
        m_bPasteActive = false;
        return;
    }

    // Before doing the next character, see if we're supposed to be
    // doing auto-newline and we haven't found the break point yet.
    // Note that auto-newline interacts poorly with tab conversion, because
    // it works by looking ahead some number of characters in the 
    // paste string.
    if (m_pasteNextIndex == 0)
    {
        // First, check if we need to break at all.  If the count of
        // chars left is <= the autoLF setting, then there is nothing
        // to wrap.
        if (m_pasteLen - m_pasteIndex <= m_autoLF)
        {
            m_pasteNextIndex = -1;
        }
        else
        {
            i = m_pasteText.find_last_of (" -", m_pasteIndex + m_autoLF - 1);
            if (i < m_pasteIndex || i == (int)wxString::npos)
            {
                // If there is no good break point, break at the limit.
                i = m_pasteIndex + m_autoLF - 1;
            }
            m_pasteNextIndex = i;
        }
    }
    
    nextindex = m_pasteIndex;
    // Pick up the next two characters, advancing the index past the
    // first one only.  Sometimes we need the extra character lookahead.
    c = m_pasteText[nextindex++];
    if (nextindex < m_pasteLen)
    {
        c2 = m_pasteText[nextindex];
    }
    
#if 0
    tracex ("Pasting at index %d:  %d, next is %d", m_pasteIndex, c, c2);
#endif

    // Line endings vary, and on Mac they are not even consistent from
    // one application to the next.  Fix that.
    if (c == 015)
    {
        // CR.  Skip if next is LF.  Either way, supply LF for current char.
        c = '\n';
        if (c2 == '\n')
        {
            nextindex++;
        }
    }
    
    // Check if we're at the line break position, and we have a space.
    // If yes, remove it (the newline will be inserted at the end)
    if (m_pasteIndex == m_pasteNextIndex && c == ' ')
    {
        c = '\0';
    }
    
    if (m_pastePrint)
    {
        // Pasting a printout string, with ' for shift and other fun stuff.
        if (c < sizeof (printoutToPlato) / sizeof (printoutToPlato[0]))
        {
            pp = printoutToPlato[c];

            if (pp == -2)
            {
                // Shift code.  Look up the next character.
                pp = printoutToPlato[c2];
                // Look for a shift code preceding a character that is
                // a shifted character (like $), or an unshifted
                // character whose shifted form corresponds to a
                // different printable character (like 4).  For those
                // cases, if we see a shift code, send that
                // separately.  For example, '4 does not mean $, it
                // means a shift code then 4 (which is an embedded
                // mode change).  Note that we also do this if the 
                // character after the ' is not recognized.
                if ((pp & 040) != 0 || c2 == '=' ||
                    (c2 >= '0' && c2 <= '9'))
                {
                    ptermSendKey1 (055);     // shift-Assign is shift code
                }
                else
                {
                    // Regular shifted key, send that and skip
                    ptermSendKey1 (pp | 040);
                    nextindex++;
                }
            }
            else if (pp != -1)
            {
                ptermSendKey1 (pp);
            }
        }
    }
    else
    {
        // Regular paste.  This is a lot harder because we have to
        // translate Unicode characters to PLATO.

        // By default, each character pasted is taken to use one
        // display position.  This is how we do tab handling and
        // auto-newline.
        nextpos = m_pasteLinePos + 1;
        
        // Smart paste processing.  This recognizes spaces that go to 
        // the next multiple of 8 tab stop, and the sequences <( and )>
        // for embed open and close.
        if (m_smartPaste || m_convDot7 || m_conv8Sp)
        {
            if (c == '<' && c2 == '(' && m_smartPaste)
            {
                // open embed
                c = L'\u2993';
                nextindex++;
            }
            else if (c == ')' && c2 == '>' && m_smartPaste)
            {
                // close embed
                c = L'\u2994';
                nextindex++;
            }
            else if (c == ' ' && c2 == ' ' && (m_conv8Sp || m_smartPaste))
            {
                // We only substitute tab for at least two spaces.
                // We have two now; see if there are enough additional
                // ones to get to the next tab stop.
                const int ts = ((m_pasteLinePos + 8) & (~7)) - m_pasteLinePos;
                if (ts == 2)
                {
                    // Just those two gets us to the tabstop.  Do it.
                    c = '\t';
                    nextindex++;
                    nextpos++;
                }
                else if (m_pasteIndex + ts < m_pasteLen)
                {
                    // Need more, and we're not at end of string.  Check
                    // for more spaces.
                    for (i = 2; i < ts; i++)
                    {
                        if (m_pasteText[m_pasteIndex + i] != ' ')
                        {
                            break;
                        }
                    }
                    if (i == ts)
                    {
                        // Spaces all the way to the next tab.
                        c = '\t';
                        nextindex = m_pasteIndex + ts;
                        nextpos = m_pasteLinePos + ts;
                    }
                }
            }
            else if (c == '.' && c2 == ' ' && (m_convDot7 || m_smartPaste))
            {
                // We only substitute tab for at least two spaces.
                // We have two now; see if there are enough additional
                // ones to get to the next tab stop.
                const int ts = ((m_pasteLinePos + 8) & (~7)) - m_pasteLinePos;
                if (ts == 2)
                {
                    // Just those two gets us to the tabstop.  Do it.
                    dot7 = true;
                    nextindex++;
                    nextpos++;
                }
                else if (m_pasteIndex + ts < m_pasteLen)
                {
                    // Need more, and we're not at end of string.  Check
                    // for more spaces.
                    for (i = 2; i < ts; i++)
                    {
                        if (m_pasteText[m_pasteIndex + i] != ' ')
                        {
                            break;
                        }
                    }
                    if (i == ts)
                    {
                        // Spaces all the way to the next tab.
                        dot7 = true;
                        nextindex = m_pasteIndex + ts;
                        nextpos = m_pasteLinePos + ts;
                    }
                }
            }
        }
        
        // One more special case to handle: A with ring can appear either
        // as combined or as separated.  It's a single character in PLATO,
        // represented in the unicodeToPlato table by its combined encoding.
        // If we see the separate code, form the combined.
        if (c2 == L'\u030a')
        {
            // Found "combining ring above" after character c.  The only
            // ones we handle now are a and A, so check.
            if (c == 'a')
            {
                c = L'\u00e5';
                nextindex++;
            }
            else if (c == 'A')
            {
                c = L'\u00c5';
                nextindex++;
            }
        }

        // Combining accents don't take up a column
        if (c >= L'\u0300' && c <= L'\u033f')
        {
            nextpos = m_pasteLinePos;
        }

        if (c < (sizeof (asciiToPlato) / sizeof (asciiToPlato[0])))
        {
            p = pastedAsciiToPlato[c];
        }
        else
        {
            // Out of ASCII range.  Look for a match in the Unicode table.
            p = None;
            for (i = 0;
                 i < sizeof (unicodeToPlato) / sizeof (unicodeToPlato[0]);
                 i++)
            {
                if (unicodeToPlato[i].u == c)
                {
                    p = unicodeToPlato[i].p;
                    break;
                }
            }
        }
        
        // Send what we found, if anything.  Note that we don't change
        // the current position if we don't send a key.
        if (p != None)
        {
            ptermSendKey (p);
            m_pasteLinePos = nextpos;
            if (dot7)
            {
                ptermSendKey (pastedAsciiToPlato[(int)'\t']);
            }
        }
    }

    if (c == '\n' && m_autoLF != 0)
    {
        // Newline and splitting lines, next time we'll find the next
        // break point.
        m_pasteNextIndex = 0;
    }
    else if (m_pasteIndex == m_pasteNextIndex)
    {
        // This is the spot where we want to break.  Send a NEXT,
        // then skip spaces.  Then start looking for the next split point.
        ptermSendKey1 (026);
        while (nextindex < m_pasteLen && m_pasteText[nextindex] == ' ')
        {
            nextindex++;
        }
        m_pasteNextIndex = 0;
    }
    
    if (nextindex < m_pasteLen)
    {
        // Still more to do.  Update the index (which is cleared to -1
        // by ptermSendKey), then restart the timer with the
        // appropriate delay (char delay or line delay).
        m_pasteIndex = nextindex;
        if (c == '\n')
        {
            delay = m_lineDelay;
            m_pasteLinePos = 0;
        }
        else
        {
            delay = m_charDelay;
            // this double counts;  see after ptermSendKey (p) above - drs 
            //m_pasteLinePos++;
        }
        m_pasteTimer.Start (delay, true);
        m_bPasteActive = true;
    }
    else
    {
        // reset flags
        m_bCancelPaste = false;
        m_bPasteActive = false;
    }
}

void PtermFrame::OnClose (wxCloseEvent &)
{
    if (!m_profile->m_lockPosition)
    {
        int x, y;

        // Save the position of this window as our preferred position
        GetPosition (&x, &y);
        PtermProfile *profile2 = new PtermProfile (m_profile->m_profileName, true);
        profile2->m_restoreX = x;
        profile2->m_restoreY = y;
        profile2->SaveProfile ();
        delete profile2;

        debug ("Window position on exit is %d, %d", x, y);
    }

    m_MTFiles[0].Close();
    m_MTFiles[1].Close();
    
    Destroy ();
}

void PtermFrame::OnConnectAgain (wxCommandEvent&)
{
    PtermProfile *prof = new PtermProfile (*m_profile);
    
    ptermApp->DoConnect (prof);
}

void PtermFrame::OnQuit (wxCommandEvent&)
{
    // true is to force the frame to close
    Close (true);
}

void PtermFrame::OnActivate (wxActivateEvent &event)
{
    if (m_canvas != NULL)
    {
        m_canvas->SetFocus ();
    }
    event.Skip ();        // let others see the event, too
}

void PtermFrame::OnCopyScreen (wxCommandEvent &)
{
    wxBitmapDataObject *screen;

    screen = new wxBitmapDataObject (*m_bitmap);

    if (wxTheClipboard->Open ())
    {
        if (!wxTheClipboard->SetData (screen))
        {
            wxLogError (_("Can't copy image to the clipboard"));
        }
        wxTheClipboard->Close ();
    }
    else
    {
        wxLogError (_("Can't open clipboard."));
    }
}

#if !defined (__WXMAC__)
void PtermFrame::OnToggleMenuBar (wxCommandEvent &)
{
    //toggle menu
    m_showMenuBar = m_profile->m_showMenuBar = !m_showMenuBar;

    // Make sure both menus are up to date
    menuPopup->Check (Pterm_ToggleMenuBar, m_showMenuBar);
    menuView->Check (Pterm_ToggleMenuBar, m_showMenuBar);

    if (!IgnoreKeys())
    {
        menuPopup->Check (Pterm_ToggleStatusBar, m_showStatusBar);
        menuView->Check (Pterm_ToggleStatusBar, m_showStatusBar);
    }

    if (!m_showMenuBar)
    {
        SetMenuBar (NULL);
    }
    else
    {
        SetMenuBar (menuBar);
    }
    UpdateDisplayState ();
}
#endif

void PtermFrame::OnToggleStatusBar (wxCommandEvent &)
{
    //toggle status
    m_showStatusBar = m_profile->m_showStatusBar = !m_showStatusBar;

    // Make sure both menus are up to date
    menuPopup->Check (Pterm_ToggleStatusBar, m_showStatusBar);
    menuView->Check (Pterm_ToggleStatusBar, m_showStatusBar);

    BuildStatusBar ();

    UpdateDisplayState ();
}

void PtermFrame::OnSetScaleEntry (wxCommandEvent &evt)
{
    int i = evt.GetId () - Pterm_SetScaleEntry;
    
    // Set new scale value
    m_scale = m_profile->m_scale = scaleList[i];

    // Make sure both menus are up to date
    menuPopup->Check (evt.GetId (), m_showStatusBar);
    menuView->Check (evt.GetId (), m_showStatusBar);

    UpdateDisplayState ();
}

void PtermFrame::OnSetStretchMode (wxCommandEvent &)
{

    // Set to free scaling
    m_scale = m_profile->m_scale = SCALE_FREE;

    // Make sure both menus are up to date
    menuPopup->Check (Pterm_ToggleStretchMode, m_showStatusBar);
    menuView->Check (Pterm_ToggleStretchMode, m_showStatusBar);

    // refit
    UpdateDisplayState ();
}

void PtermFrame::OnSetAspectMode (wxCommandEvent &)
{

    // Set to aspect ratio preserved stretching
    m_scale = m_profile->m_scale = SCALE_ASPECT;

    // Make sure both menus are up to date
    menuPopup->Check (Pterm_ToggleAspectMode, m_showStatusBar);
    menuView->Check (Pterm_ToggleAspectMode, m_showStatusBar);

    // refit
    UpdateDisplayState ();
}

void PtermFrame::OnLockPosition (wxCommandEvent &event)
{
    if (m_profile->m_lockPosition)
    {
        m_profile->m_lockPosition = false;

        PtermProfile *profile2 = new PtermProfile (m_profile->m_profileName, true);
        profile2->m_lockPosition = false;
        profile2->SaveProfile ();
        delete profile2;
    }
    else
    {
        int x, y;

        // Save the position of this window as our preferred position
        GetPosition (&x, &y);

        m_profile->m_lockPosition = true;
        m_profile->m_restoreX = x;
        m_profile->m_restoreY = y;

        PtermProfile *profile2 = new PtermProfile (m_profile->m_profileName, true);
        profile2->m_restoreX = x;
        profile2->m_restoreY = y;
        profile2->m_lockPosition = true;
        profile2->SaveProfile ();
        delete profile2;
    }

    BuildMenuBar ();
    BuildPopupMenu ();
}

void PtermFrame::OnRestorePosition (wxCommandEvent &event)
{
    Move (ForceValidStartPoint(m_profile->m_restoreX, m_profile->m_restoreY));
}

void PtermFrame::OnCopy (wxCommandEvent &)
{
    wxString text = GetRegionText ();

    if (!wxTheClipboard->Open ())
    {
        wxLogError (_("Can't open clipboard."));

        return;
    }

    if (!wxTheClipboard->SetData (new wxTextDataObject (text)))
    {
        wxLogError (_("Can't copy text to the clipboard"));
    }

    wxTheClipboard->Close ();
}

void PtermFrame::OnExec (wxCommandEvent &)
{
    wxString url = GetRegionText (true);

    wxLaunchDefaultBrowser (url, wxBROWSER_NEW_WINDOW | wxBROWSER_NOBUSYCURSOR);
}

void PtermFrame::OnMailTo (wxCommandEvent &)
{
    wxString l_FixText;
    wxString newchr;
    wxString pnt;
    int cnt;

    for (pnt = GetRegionText (), cnt = 0; pnt[cnt]; cnt++)
    {
        if (pnt[cnt] == '/')
            newchr = wxChar ('@');
        //fix ' at ' , '(at)', and '[at]'
        else if (pnt[cnt] == ' ' && pnt[cnt+1] == 'a' &&
                 pnt[cnt+2] == 't' && pnt[cnt+3] == ' ')
            cnt += 3, newchr = wxChar ('@');
        else if (pnt[cnt] == '(' && pnt[cnt+1] == 'a' &&
                 pnt[cnt+2] == 't' && pnt[cnt+3] == ')')
            cnt += 3, newchr = wxChar ('@');
        else if (pnt[cnt] == '[' && pnt[cnt+1] == 'a' &&
                 pnt[cnt+2] == 't' && pnt[cnt+3] == ']')
            cnt += 3, newchr = wxChar ('@');
        //fix ' dot ' , '(dot)', and '[dot]'
        else if (pnt[cnt] == ' ' && pnt[cnt+1] == 'd' && 
                 pnt[cnt+2] == 'o' && pnt[cnt+3] == 't' &&
                 pnt[cnt+4] == ' ')
            cnt += 4, newchr = wxChar ('.');
        else if (pnt[cnt] == '(' && pnt[cnt+1] == 'd' &&
                 pnt[cnt+2] == 'o' && pnt[cnt+3] == 't' &&
                 pnt[cnt+4] == ')')
            cnt += 4, newchr = wxChar ('.');
        else if (pnt[cnt] == '[' && pnt[cnt+1] == 'd' &&
                 pnt[cnt+2] == 'o' && pnt[cnt+3] == 't' &&
                 pnt[cnt+4] == ']')
            cnt += 4, newchr = wxChar ('.');
        //strip 'nospam'
        else if (pnt[cnt] == 'n' && pnt[cnt+1] == 'o' &&
                 pnt[cnt+2] == 's' && pnt[cnt+3] == 'p' &&
                 pnt[cnt+4] == 'a' && pnt[cnt+5] == 'm')
            cnt += 5, newchr = wxChar ('*');
        //fix comma
        else if (pnt[cnt] == ',')
            newchr = wxChar ('.');
        else
            newchr = pnt[cnt];
        if (newchr != '*')
            l_FixText += newchr;
    }
    wxLaunchDefaultBrowser ("mailto:" + l_FixText,
                            wxBROWSER_NEW_WINDOW | wxBROWSER_NOBUSYCURSOR);
}

void PtermFrame::OnSearchThis (wxCommandEvent &)
{
    wxString text = GetRegionText (true);

    debug (m_SearchURL + text);
    wxLaunchDefaultBrowser (m_SearchURL + text,
                            wxBROWSER_NEW_WINDOW | wxBROWSER_NOBUSYCURSOR);
}

void PtermFrame::OnMacro0 (wxCommandEvent &)
{
    static const int key[] = {0034, 0034, 0034, 0034, 0034, 0034, 0034,
                              0034, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro1 (wxCommandEvent &)
{
    static const int key[] = {0024, 0000, 0103, 0137, 0132, 0103, 0136, 
                              0105, 0122, 0122, 0106, 0024, 0001, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro2 (wxCommandEvent &)
{
    static const int key[] = {0024, 0000, 0103, 0137, 0132, 0103, 0136,
                              0111, 0116, 0106, 0117, 0024, 0001, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro3 (wxCommandEvent &)
{
    static const int key[] = {0024, 0000, 0103, 0137, 0132, 0103, 0136,
                              0113, 0105, 0131, 0123, 0024, 0001, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro4 (wxCommandEvent &)
{
    static const int key[] = {0024, 0000, 0103, 0137, 0132, 0103, 0136,
                              0124, 0105, 0130, 0124, 0024, 0001, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro5 (wxCommandEvent &)
{
    static const int key[] = {0103, 0117, 0114, 0117, 0122, 0100, 0100,
                              0100, 0104, 0111, 0123, 0120, 0114, 0101,
                              0131, 0134, 0132, 0103, 0136, 0105, 0122,
                              0122, 0106, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro6 (wxCommandEvent &)
{
    static const int key[] = {0103, 0117, 0114, 0117, 0122, 0100, 0100,
                              0100, 0104, 0111, 0123, 0120, 0114, 0101,
                              0131, 0134, 0132, 0103, 0136, 0111, 0116,
                              0106, 0117, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro7 (wxCommandEvent &)
{
    static const int key[] = {0103, 0117, 0114, 0117, 0122, 0100, 0100,
                              0100, 0104, 0111, 0123, 0120, 0114, 0101,
                              0131, 0134, 0132, 0103, 0136, 0113, 0105,
                              0131, 0123, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro8 (wxCommandEvent &)
{
    static const int key[] = {0103, 0117, 0114, 0117, 0122, 0100, 0100,
                              0100, 0104, 0111, 0123, 0120, 0114, 0101,
                              0131, 0134, 0132, 0103, 0136, 0124, 0105,
                              0130, 0124, -1};
    ptermSendKeys (key);
}
void PtermFrame::OnMacro9 (wxCommandEvent &)
{
                // 8boxes, <c,zc.keys> 2 boxes <c,zc.text>
    static const int key0[] = {0034, 0034, 0034, 0034, 0034, 0034, 0034,
                               0034, -1};
    ptermSendKeys (key0);
    static const int key3[] = {0024, 0000, 0103, 0137, 0132, 0103, 0136,
                               0113, 0105, 0131, 0123, 0024, 0001, -1};
    ptermSendKeys (key3);
    static const int key[] = {0034, 0034, -1};
    ptermSendKeys (key);
    static const int key4[] = {0024, 0000, 0103, 0137, 0132, 0103, 0136,
                               0124, 0105, 0130, 0124, 0024, 0001, -1};
    ptermSendKeys (key4);
}

void PtermFrame::OnPaste (wxCommandEvent &event)
{
    if (!wxTheClipboard->Open ())
    {
        wxLogError (_("Can't open clipboard."));

        return;
    }

    if (!wxTheClipboard->IsSupported (wxDF_TEXT))
    {
        wxLogWarning (_("No text data on clipboard"));

        wxTheClipboard->Close ();
        return;
    }

    wxTextDataObject text;

    if (!wxTheClipboard->GetData (text))
    {
        wxLogError (_("Can't paste data from the clipboard"));
    }
    else
    {
        m_pasteText = text.GetText ();
        m_pasteLen = m_pasteText.Len ();
        m_pasteIndex = 0;
        if (m_autoLF != 0)
        {
            m_pasteNextIndex = 0;
        }
        else
        {
            m_pasteNextIndex = -1;  // "don't do anything"
        }
        m_pasteTimer.Start (m_charDelay, true);
        m_pastePrint = (event.GetId () == Pterm_PastePrint);
        m_pasteLinePos = 0;
    }

    wxTheClipboard->Close ();
}

void PtermFrame::OnUpdateUIPaste (wxUpdateUIEvent& event)
{
#ifdef __WXDEBUG__
    // too many trace messages if we don't do it - this function is called
    // very often
    wxLogNull nolog;
#endif

    event.Enable (wxTheClipboard->IsSupported (wxDF_TEXT));
}

void PtermFrame::OnSaveScreen (wxCommandEvent &)
{
    wxMemoryDC screenDC;
    wxString filename, ext;
    wxBitmapType type;
    wxFileDialog fd (this, _("Save screen to"), ptermApp->m_defDir,
                     wxT (""),
                     wxT ("PNG files (*.png)|*.png|")
                     wxT ("TIF files (*.tif)|*.tif|")
                     wxT ("BMP files (*.bmp)|*.bmp|")
                     wxT ("PNM files (*.pnm)|*.pnm|")
                     wxT ("XPM files (*.xpm)|*.xpm"),
                     wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
    int idx;
    // This list must match order and content of the filter list above
    static const wxChar *exts[] = { wxT ("png"), wxT ("tif"),
                                    wxT ("bmp"), wxT ("pnm"),
                                    wxT ("xpm") };
    
    if (fd.ShowModal () != wxID_OK)
    {
        return;
    }
    filename = fd.GetPath ();
    idx = fd.GetFilterIndex ();

    wxImage screenImage = m_bitmap->ConvertToImage ();
    wxFileName fn (filename);
    wxString filt_ext (exts[idx]);
    
    ptermApp->m_defDir = fn.GetPath ();
    ext = fn.GetExt ();
    if (! (ext.CmpNoCase (filt_ext) == 0 ||
           (idx == 1 && ext.CmpNoCase (wxT ("tiff")) == 0)))
    {
        // Filename extension doesn't match the selected format, fix that.
        // Note that we accept "tiff" as alternate for "tif" (filter index 1).
        ext = filt_ext;
        fn.SetFullName (fn.GetFullName () + wxT (".") + ext);
        filename = fn.GetFullPath ();
    }
    if (ext.CmpNoCase (wxT ("bmp")) == 0)
    {
        type = wxBITMAP_TYPE_BMP;
    }
    else if (ext.CmpNoCase (wxT ("png")) == 0)
    {
        type = wxBITMAP_TYPE_PNG;
    }
    else if (ext.CmpNoCase (wxT ("pnm")) == 0)
    {
        type = wxBITMAP_TYPE_PNM;
    }
    else if (ext.CmpNoCase (wxT ("tif")) == 0 ||
             ext.CmpNoCase (wxT ("tiff")) == 0)
    {
        type = wxBITMAP_TYPE_TIF;
        // 5 is LZW -- not referenced symbolically because tiff.h
        // isn't necessarily anywhere, for some reason.
        screenImage.SetOption (wxIMAGE_OPTION_COMPRESSION, 5);
    }
    else if (ext.CmpNoCase (wxT ("xpm")) == 0)
    {
        type = wxBITMAP_TYPE_XPM;
    }
    else
    {
        screenImage.SaveFile (filename);
        return;
    }
    
    screenImage.SaveFile (filename, type);
}

void PtermFrame::OnSaveAudio (wxCommandEvent &)
{
    wxString filename, ext;
    wxFileDialog fd (this, _("Save GSW audio to"), ptermApp->m_defDir,
                     wxT (""), 
                     wxT ("WAV files (*.wav)|*.wav|")
                     wxT ("AIFF files (*.aiff)|*.aiff|")
                     wxT ("AU files (*.au)|*.au"),
                     wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
    int idx, type;
    // This list must match order and content of the filter list above
    static const wxChar *exts[] = { wxT ("wav"), wxT ("aiff"),
                                    wxT ("au") };
    
    if (fd.ShowModal () != wxID_OK)
    {
        return;
    }
    filename = fd.GetPath ();
    idx = fd.GetFilterIndex ();

    wxFileName fn (filename);
    wxString filt_ext (exts[idx]);
    
    ptermApp->m_defDir = fn.GetPath ();
    ext = fn.GetExt ();
    if (ext.CmpNoCase (filt_ext) != 0)
    {
        // Filename extension doesn't match the selected format, fix that.
        ext = filt_ext;
        fn.SetFullName (fn.GetFullName () + wxT (".") + ext);
        filename = fn.GetFullPath ();
    }
    if (ext.CmpNoCase (wxT ("wav")) == 0)
    {
        type = SF_FORMAT_WAV;
    }
    else if (ext.CmpNoCase (wxT ("aiff")) == 0)
    {
        type = SF_FORMAT_AIFF;
    }
    else
    {
        type = SF_FORMAT_AU;
    }

    m_gswFFmt = type;
    m_gswFile = fn.GetFullPath ();
}

void PtermFrame::OnReset (wxCommandEvent &)
{
    m_statusBar->SetStatusText (_(" Booted from floppy"),
        STATUS_CONN);

    BootMtutor();
}

void PtermFrame::OnSessionSettings (wxCommandEvent &)
{
    //show dialog

    if (ptermApp->m_sessDialog != NULL)
    {
        return;  // user MUST close previous dialog first
    }

    ptermApp->m_sessDialog = new PtermPrefDialog (this, wxID_ANY, _ ("Session Settings..."),
        wxDefaultPosition, wxSize (470, 475), *m_profile);

    ptermApp->m_sessDialog->CenterOnParent ();
    ptermApp->m_sessDialog->Raise ();
    ptermApp->m_sessDialog->Show (true);
}

void PtermFrame::UpdateSessionSettings (void)
{
    *m_profile = *ptermApp->m_sessDialog->m_profile;

    if ( m_profile->m_noColor || m_conn->Classic ())
    {
        SetColors (m_profile->m_fgColor, m_profile->m_bgColor);
    }
    
    //get prefs
    //ptermApp->m_lastTab = m_profile->m_lastTab;
    //tab3
    m_classicSpeed = m_profile->m_classicSpeed;
    m_gswEnable = m_profile->m_gswEnable;
    m_numpadArrows = m_profile->m_numpadArrows;
    m_ignoreCapLock = m_profile->m_ignoreCapLock;
    m_platoKb = m_profile->m_platoKb;
    m_useAccel = m_profile->m_useAccel;
    m_beepEnable = m_profile->m_beepEnable;
    m_DisableShiftSpace = m_profile->m_DisableShiftSpace;
    m_DisableMouseDrag = m_profile->m_DisableMouseDrag;
    //tab4
    m_FancyScaling = m_profile->m_FancyScaling;
    m_noColor = m_profile->m_noColor;
    m_fgColor = m_profile->m_fgColor;
    m_bgColor = m_profile->m_bgColor;
    //tab5
    m_charDelay = m_profile->m_charDelay;
    m_lineDelay = m_profile->m_lineDelay;
    m_autoLF = m_profile->m_autoLF;
    m_smartPaste = m_profile->m_smartPaste;
    m_convDot7 = m_profile->m_convDot7;
    m_conv8Sp = m_profile->m_conv8Sp;
    if (m_TutorColor != m_profile->m_TutorColor)
    {
        m_TutorColor = m_profile->m_TutorColor;
        BuildMenuBar ();
        BuildPopupMenu ();
    }
    m_trimEnd = m_profile->m_trimEnd;
    //tab6
    m_SearchURL = m_profile->m_SearchURL;

    m_floppy0 = m_profile->m_floppy0;
    m_floppy1 = m_profile->m_floppy1;

    m_floppy0File = m_profile->m_floppy0File;
    m_floppy1File = m_profile->m_floppy1File;

    if (ptermApp->m_sessDialog->m_floppy0Changed)
    {
        if (m_floppy0 && m_floppy0File.Length () > 0)
            m_MTFiles[0].Open (m_floppy0File);
        else
            m_MTFiles[0].Close ();
    }

    if (ptermApp->m_sessDialog->m_floppy1Changed)
    {
        if (m_floppy1 && m_floppy1File.Length () > 0)
            m_MTFiles[1].Open (m_floppy1File);
        else
            m_MTFiles[1].Close ();
    }
    ptermApp->m_sessDialog->Destroy ();
    ptermApp->m_sessDialog = NULL;
}

void PtermFrame::OnPrint (wxCommandEvent &)
{
    wxPrintDialogData printDialogData (*g_printData);

    printDialogData.EnableSelection (false);
    printDialogData.EnablePageNumbers (false);
    
    wxPrinter printer (& printDialogData);
    
    PtermPrintout printout (this);
    if (!printer.Print (this, &printout, true /*prompt*/))
    {
        if (wxPrinter::GetLastError () == wxPRINTER_ERROR)
            wxMessageBox (_("There was a problem printing.\nPerhaps your current printer is not set correctly?"),
                          _("Printing"), wxOK | wxICON_ERROR);
    }
    else
    {
        (*g_printData) = printer.GetPrintDialogData ().GetPrintData ();
    }
}

void PtermFrame::OnPrintPreview (wxCommandEvent &)
{
    // Pass two printout objects: for preview, and possible printing.
    wxPrintDialogData printDialogData (*g_printData);
    wxPrintPreview *preview = new wxPrintPreview (new PtermPrintout (this),
                                                  new PtermPrintout (this),
                                                  &printDialogData);

    printDialogData.EnableSelection (false);
    printDialogData.EnablePageNumbers (false);
    
    if (!preview->Ok ())
    {
        delete preview;
        wxMessageBox (_("There was a problem previewing.\nPerhaps your current printer is not set correctly?"),
                      _("Previewing"), wxOK | wxICON_ERROR);
        return;
    }

    wxPreviewFrame *frame = new wxPreviewFrame (preview, this,
                                                _("Pterm Print Preview"),
                                                wxPoint (100, 100),
                                                wxSize (600, 650));
    frame->Centre (wxBOTH);
    frame->Initialize ();
    frame->Show ();
}

void PtermFrame::OnPageSetup (wxCommandEvent &)
{
    (*g_pageSetupData) = *g_printData;

    wxPageSetupDialog pageSetupDialog (this, g_pageSetupData);
    pageSetupDialog.ShowModal ();

    (*g_printData) = pageSetupDialog.GetPageSetupData ().GetPrintData ();
    (*g_pageSetupData) = pageSetupDialog.GetPageSetupData ();

}

void PtermFrame::OnFullScreen (wxCommandEvent &)
{
    m_fullScreen = !m_fullScreen;

    // Set the menu/popup check marks.  Note that there is no menubar
    // in full screen mode, so no full screen check on the menubar!
    //menuPopup->Check (Pterm_FullScreen, m_fullScreen);
    
    // If we're switching to full screen mode, save the current
    // window position and size
    if (m_fullScreen)
    {
        m_rect = GetRect ();
    }
    
    // Tell wxWidgets the desired full screen mode.
    ShowFullScreen (m_fullScreen);

    // If we're exiting full screen mode, restore the window position
    // and size
    if (!m_fullScreen)
    {
        SetSize (m_rect);
    }
    
    UpdateDisplayState ();
}

void PtermFrame::OnResize (wxSizeEvent& )
{
    UpdateDisplayState ();
}

// This method recalculates all the display control variables: full screen
// mode, scale values, virtual size, etc., based on the current display
// mode flags and the window or display size.
void PtermFrame::UpdateDisplayState (void)
{
    int client_h, client_w, canvas_h, canvas_w;
    wxDisplay d (wxDisplay::GetFromWindow (this));
    wxRect r;

    if (m_canvas == NULL)
    {
        return;
    }

    if (m_fullScreen)
    {
        r = d.GetGeometry ();
        client_w = r.width;
        client_h = r.height;
    }
    else
    {
        GetClientSize (&client_w, &client_h);
    }

    if (m_profile->m_scale != SCALE_FREE)
    {
        if (client_h < client_w)
        {
            canvas_h = canvas_w = client_h;
        }
        else
        {
            canvas_h = canvas_w = client_w;
        }
    }
    else
    {
        canvas_h = client_h;
        canvas_w = client_w;
    }
    m_canvas->SetSize (client_w, client_h);

    // If stretching, the client and virtual sizes are the same, and
    // we scale the image to match.  Otherwise, the scaling is some
    // integer (or half-integer, if a Retina display is used) factor,
    // and the client size is 512 * the scale, plus margins.
    // The margin should scale along with the bitmap, otherwise it will
    // result in an optically smaller margin for larger bitmaps.
    // When drawing, the offset is also scaled by UserScale, so must
    // scale m_xmargin and m_ymargin down appropriately.
    if (m_scale == SCALE_ASPECT || m_scale == SCALE_FREE)
    {
        m_xscale = canvas_w / (512.0 + 2 * DisplayMargin);
        m_yscale = canvas_h / (512.0 + 2 * DisplayMargin);
        m_xmargin = (int) ((client_w - m_xscale * 512.0) / 2.0 / m_xscale);
        m_ymargin = (int) ((client_h - m_yscale * 512.0) / 2.0 / m_yscale);
        m_canvas->SetVirtualSize (client_w, client_h);
    }
    else
    {
        m_xscale = m_yscale = m_scale;
        if (m_fullScreen)
        {
            m_xmargin = (int) ((client_w - m_xscale * 512.0) / 2.0 / m_xscale);
            m_ymargin = (int) ((client_h - m_yscale * 512.0) / 2.0 / m_yscale);
        }
        else
        {
            m_xmargin = m_ymargin = DisplayMargin;
        }
        m_canvas->SetVirtualSize (XSize, YSize);
    }

    // Turn off scrollbars in full screen mode.
    if (m_fullScreen)
    {
        m_canvas->SetScrollRate (0, 0);
    }
    else
    {
        m_canvas->SetScrollRate (1, 1);
    }

    // Set the scale for the display window
    wxClientDC dc (m_canvas);

    dc.SetUserScale (m_xscale, m_yscale);

    // Set the window size, if we're selecting a fixed scale value.
    if (m_scale != SCALE_ASPECT && m_scale != SCALE_FREE && !m_fullScreen)
    {
        SetClientSize (XSize, YSize);
    }
    
    // Update the display and return focus to the current display window.
    m_canvas->Refresh (false);
    m_canvas->SetFocus ();
}

#if defined (__WXMSW__)
void PtermFrame::OnIconize (wxIconizeEvent &)
{
    // this helps control to a certain extent, the scrollbars that
    // sometimes appear when restoring from iconized state.
    if (!IsIconized ())
    {
        UpdateDisplayState ();
    }
}

void PtermFrame::fixAlpha (void)
{
    PixelData pixmap (*m_bitmap);
    PixelData::Iterator p (pixmap);
    int x, y;
    u32 *pmap;

    for (y = 0; y < 512; y++)
    {
        p.MoveTo (pixmap, XMADJUST (0), YMADJUST (y));
        for (x = 0; x < 512; x++)
        {
            pmap = (u32 *)(p.m_ptr);
            *pmap |= m_maxalpha;
            ++p;
        }
    }
}
#endif

void PtermFrame::ptermDrawChar (int x, int y, int snum, int cnum, bool autobs)
{
    u32 fpix, bpix;
    const u16 *charp, *svcharp;
    PixelData pixmap (*m_bitmap);
    PixelData selmap (*m_selmap);
    
    // Drawing a character is done simply by drawing the dots one by one.
    if (snum == 0)
    {
        charp = plato_m0;
    }
    else if (snum == 1)
    {
        charp = plato_m1;
    }
    else
    {
        charp = plato_m23 + (snum - 2) * (8 * 64);
    }
    charp += 8 * cnum;
    svcharp = charp;
    //debug ("char %d mem %d addr %p", cnum, snum, charp);

    if (modexor || (wemode & 1))
    {
        // mode rewrite or write
        fpix = m_fgpix;
        bpix = m_bgpix;
    }
    else
    {
        // mode inverse or erase
        fpix = m_bgpix;
        bpix = m_fgpix;
        if (wemode == 2)
        {
            // mode erase, so clear the savemap entry (write M0 entry 055
            // which is a space)
            svcharp = plato_m0 + 8 * 055;
        }
    }

    // We draw the character twice: once onto the screen bitmap,
    // and once onto the selection region bitmap.  The latter reflects
    // the text currently stored in the savemap, which is coarse grid
    // aligned.  Selection region bitmap entries are normally drawn
    // in mode rewrite, except for autobackspace where we want to
    // save the resulting combined character shape.
    ptermDrawCharInto (x, y, charp, fpix, bpix, mode, modexor, pixmap);
    ptermDrawCharInto (x & 0770, y & 0760, svcharp, m_selpixf, m_selpixb,
                       (autobs ? 3 : 1), false, selmap);
}

void PtermFrame::ptermDrawCharInto (int x, int y, const u16 *charp,
                                    u32 fpix, u32 bpix, int cmode,
                                    bool xor_p, PixelData &pixmap)
{
    int &cx = (vertical) ? y : x;
    int &cy = (vertical) ? x : y;
    int i, j, saveY, dx, dy, sdy;
    u16 charw;

    saveY = cy;
    dx = dy = (large) ? 2 : 1;
    sdy = 1;
    if (vertical)
    {
        sdy = -1;
        dy = -dy;
    }

    for (j = 0; j < 8; j++)
    {
        cy = saveY;
        charw = *charp++;
        for (i = 0; i < 16; i++)
        {
            if ((charw & 1) == 0)
            {
                // background, do we erase it?
                if ((cmode & 2) == 0)
                {
                    ptermUpdatePoint (x, y, bpix, false, pixmap);
                    if (large)
                    {
                        ptermUpdatePoint (x + 1, y, bpix, false, pixmap);
                        ptermUpdatePoint (x, y + sdy, bpix, false, pixmap);
                        ptermUpdatePoint (x + 1, y + sdy, bpix, false, pixmap);
                    }
                }
            }
            else
            {
                ptermUpdatePoint (x, y, fpix, xor_p, pixmap);
                if (large)
                {
                    ptermUpdatePoint (x + 1, y, fpix, xor_p, pixmap);
                    ptermUpdatePoint (x, y + sdy, fpix, xor_p, pixmap);
                    ptermUpdatePoint (x + 1, y + sdy, fpix, xor_p, pixmap);
                }
            }
            charw >>= 1;
            cy += dy;
        }
        cx += dx;
    }
}

void PtermFrame::ptermDrawPoint (int x, int y)
{
    PixelData pixmap (*m_bitmap);

    if (modexor || (wemode & 1))
    {
        // mode rewrite or write
        ptermUpdatePoint (x, y, m_fgpix, modexor, pixmap);
    }
    else
    {
        // mode inverse or erase
        ptermUpdatePoint (x, y, m_bgpix, false, pixmap);
    }
}

void PtermFrame::ptermDrawLine (int x1, int y1, int x2, int y2)
{
    int dx, dy;
    int stepx, stepy;

    dx = x2 - x1;
    dy = y2 - y1;
    if (dx < 0) { dx = -dx;  stepx = -1; } else { stepx = 1; }
    if (dy < 0) { dy = -dy;  stepy = -1; } else { stepy = 1; }
    dx <<= 1;
    dy <<= 1;
    
    // draw first point
    ptermDrawPoint (x1, y1);
    
    //check for shallow line
    if (dx > dy) 
    {
        int fraction = dy - (dx >> 1);
        while (x1 != x2) 
        {
            if (fraction >= 0) 
            {
                y1 += stepy;
                fraction -= dx;
            }
            x1 += stepx;
            fraction += dy;
            ptermDrawPoint (x1, y1);
        }
    } 
    //otherwise steep line
    else 
    {
        int fraction = dx - (dy >> 1);
        while (y1 != y2) 
        {
            if (fraction >= 0) 
            {
                x1 += stepx;
                fraction -= dy;
            }
            y1 += stepy;
            fraction += dx;
            ptermDrawPoint (x1, y1);
        }
    }
}

void PtermFrame::ptermFullErase (void)
{
    const bool savexor = modexor;
    const int savemode = mode;
    wxClientDC dc (m_canvas);

    m_usefont = false;

    // We'll simply handle this as a mode-erase block erase operation
    // for the whole screen (0..512 in x and y).
    modexor = false;
    mode = 2;   // erase
    ptermBlockErase (0, 0, 511, 511);
    modexor = savexor;
    mode = savemode;

    ClearRegion ();
}

void PtermFrame::ptermBlockErase (int x1, int y1, int x2, int y2)
{
    int t;
    int x, y;
    u32 pix;
    PixelData pixmap (*m_bitmap);
    PixelData selmap (*m_selmap);
    
    if (x1 > x2)
        t = x1, x1 = x2, x2 = t;
    if (y1 > y2)
        t = y1, y1 = y2, y2 = t;
    
    if (modexor || (wemode & 1))
    {
        // mode rewrite or write
        pix = m_fgpix;
    }
    else
    {
        // mode inverse or erase
        pix = m_bgpix;
    }

    for (y = y1; y <= y2; y++)
    {
        for (x = x1; x <= x2; x++)
        {
            ptermUpdatePoint (x, y, pix, modexor, pixmap);
        }
    }
    
    // Wipe text map -- specifically, set it to all spaces.
    int scol = int (x1 / 8);
    int cols = int (ceil (double ((x2 - x1) / 8))) + 1;
    int srow = int (y1 / 16);
    int rows = int (ceil (double ((y2 - y1) / 16))) + 1;
    for (int row = srow; row < srow + rows; row++)
    {
        for (int col = scol; col < scol + cols; col++)
        {
            textmap[row * 64 + col][0] = ' ';
            textmap[row * 64 + col][1] = '\0';
            textmap[row * 64 + col][2] = '\0';
            textmap[row * 64 + col][3] = '\0';
        }
    }
    
    // Wipe the corresponding region of the selection image
    for (y = srow * 16; y < (srow + rows) * 16; y++)
    {
        for (x = scol * 8; x < (scol + cols) * 8; x++)
        {
            ptermUpdatePoint (x, y, m_selpixb, false, selmap);
        }
    }
}

// -paint- (flood fill) with foreground color if "pat" is zero, or
// the character with code "pat" otherwise.
//
// The encoding of the character code is as follows (see the PLATO
// executor source code, in file "exec7" for more detail).
//
//        *         0           = solid fill
//        *         1..95       = index into m0 character memory
//        *         129..192    = index into m1 character memory
//        *         257..383    = index into m2 (altfont) character memory
//
// For M0 and M1, the index corresponds to the ASCII code used to
// access that memory, minus 32.  So, for example, 33 is A.
//
// Note that character fill is done in the equivalent of -mode write-, 
// i.e., foreground pixels of the character pattern are written with the
// current foreground color, and background pixels are left untouched.

void PtermFrame::ptermPaint (int pat)
{
    int xm, ym;
    PixelData pixmap (*m_bitmap);
    
    xm = XMADJUST (currentX);
    ym = YMADJUST (currentY);

    ptermPaintWalker (xm, ym, pixmap, pat, 0);
    ptermPaintWalker (xm, ym, pixmap, pat, 1);
}

// Pass 0 means: stop if you hit background pixels; set all other pixels
// as visited.
// Pass 1 means: stop if you hit a pixel that's not been marked as visited;
// for a visited pixel, set it to foreground if it is supposed to be
// painted, or back to not visited if it is supposed to be unchanged.
//
// Since normal pixel values all have alpha == 255, we use alpha == 0
// as the marker value.
#define wdone(pmap, pass) ((pass && (*pmap & m_maxalpha) != 0) ||   \
                           (!pass && (*pmap == m_bgpix ||           \
                                      (*pmap & m_maxalpha) == 0)))

// This stack is used to implement what amounts to the trivial recursive
// fill algorithm without actual recursion.  All we need is one byte per
// recursion level, which is an acceptable hit.  Worst case (filling a 
// blank screen) depth is the number of pixels on the screen, plus one
// because we use one to visit a pixel that is already filled or is not
// going to be filled.  So allocate that plus one more; the one extra
// entry allows a stack overflow sanity check.
static u8 walkstack[512 * 512 + 2];

void PtermFrame::ptermPaintWalker (int x, int y, PixelData & pixmap, 
                                   int pat, int pass)
{
    PixelData::Iterator p (pixmap);
    u32 *pmap;
    int sp;
#define PUSH walkstack[++sp] = 0
    int maxsp = 0;
    int pixels = 0;
    int w, i, d;
    const u16 *cp = NULL;
    
    if (pat)
    {
        if (pat < 256)
        {
            pat += 32;
            if (pat < 128)
            {
                d = asciiM0[pat];
            }
            else
            {
                d = asciiM1[pat - 128];
            }
        }
        else
        {
            d = pat;
        }
        
        if (d == 0xff)
        {
            // Trying to do char fill with a non-character
            return;
        }
        
        // i is the set, d is the offset within the set
        i = d >> 7;
        d &= 0x7f;
        
        // Form the offset to the character pattern
        if (i == 0)
        {
            cp = plato_m0;
        }
        else if (i == 1)
        {
            cp = plato_m1;
        }
        else
        {
            cp = plato_m23 + (i - 2) * (8 * 64);
        }
        cp += 8 * d;
    }
    
    sp = -1;
    PUSH;
    while (sp >= 0)
    {
        if (sp > maxsp)
        {
            assert (sp < sizeof (walkstack) - 1);
            maxsp = sp;
        }
        p.MoveTo (pixmap, x, y);
        pmap = (u32 *)(p.m_ptr);

        // Each time through the loop we increment the top of stack
        // value, to reflect progress in the walk
        w = walkstack[sp];
        walkstack[sp]++;
        
        switch (w)
        {
        case 0:
            // If the pixel is already filled, leave this level.
            // Otherwise, fill the pixel and explore to the left.
            if (wdone (pmap, pass))
            {
                walkstack[sp] = 4;
                break;
            }
            if (pass)
            {
                if (cp != NULL)
                {
                    // Character fill.  We draw the characters on 
                    // coarse grid boundaries.
                    const int cx = x & 7;
                    const int cy = y & 15;

                    if ((cp[cx] & (0x8000 >> cy)) != 0)
                    {
                        // Foreground pixel, paint it
                        *pmap = m_fgpix;
                    }
                    else
                    {
                        // Backround pixel, unmark it
                        *pmap |= m_maxalpha;
                    }
                }
                else
                {
                    // Plain flood fill
                    *pmap = m_fgpix;
                }
            }
            else
            {
                // Mark the pixel by setting alpha to zero
                *pmap &= ~m_maxalpha;
            }
            pixels++;
            if (x > 0)
            {
                x--;
                PUSH;
            }
            break;
        case 1:
            // Explore to the right
            if (x < 511)
            {
                x++;
                PUSH;
            }
            break;
        case 2:
            // Explore up
            if (y < 511)
            {
                y++;
                PUSH;
            }
            break;
        case 3:
            // Explore down
            if (y > 0)
            {
                y--;
                PUSH;
            }
            break;
        case 4:
            // Done exploring at this pixel.  Pop the stack.  We have
            // to adjust the coordinate, which is done based on the
            // next to top stack entry -- that one reflects where the
            // previous level is in its exploration, i.e., which coordinate
            // adjustment it made before pushing this level.  Note that
            // the previous level entry reflects the increment of the
            // stack value, so the case labels are one higher than
            // the corresponding ones above.
            --sp;
            if (sp < 0)
            {
                break;
            }
            switch (walkstack[sp])
            {
            case 1:
                x++;
                break;
            case 2:
                x--;
                break;
            case 3:
                y--;
                break;
            case 4:
                y++;
                break;
            }
        }
    }
    
    trace ("paintwalker: %d pixels, %d max stack", pixels, maxsp);
}

void PtermFrame::ptermSetName (wxString &winName)
{
    wxString str;
    
    if (winName.IsEmpty ())
    {
        str = wxT ("Pterm");
    }
    else
    {
        str.Printf (wxT ("Pterm: %s"), winName);
    }
    SetTitle (str);
}

void PtermFrame::ptermSetStatus (wxString &str)
{
    if (m_statusBar != NULL)
    {
        m_statusBar->SetStatusText (str, STATUS_CONN);
    }
}

void PtermFrame::SetColors (wxColour &newfg, wxColour &newbg)
{
    union {
        u32 pix;
        u8 p[4];
    } cvtpix;
    
    trace ("fg: %d %d %d; bg: %d %d %d", newfg.Red (), newfg.Green (),
           newfg.Blue (), newbg.Red (), newbg.Green (), newbg.Blue ());

    m_defFg = newfg;
    m_defBg = newbg;

    // Calculate the new pixel values
    cvtpix.pix = m_maxalpha;
    cvtpix.p[m_red] = newfg.Red ();
    cvtpix.p[m_green] = newfg.Green ();
    cvtpix.p[m_blue] = newfg.Blue ();
    m_fgpix = cvtpix.pix;
    cvtpix.pix = m_maxalpha;
    cvtpix.p[m_red] = newbg.Red ();
    cvtpix.p[m_green] = newbg.Green ();
    cvtpix.p[m_blue] = newbg.Blue ();
    m_bgpix = cvtpix.pix;
    
}

void PtermFrame::drawFontChar (int x, int y, int c)
{
    wxString chr;

    chr.Printf (wxT ("%c"), c);

    m_memDC->SelectObject (*m_bitmap);
    switch (wemode)
    {
    case 0:         // inverse
        m_memDC->SetBackgroundMode (wxSOLID);
        m_memDC->SetTextBackground (m_currentFg);
        m_memDC->SetTextForeground (m_currentBg);
        break;
    case 1:         // rewrite
        m_memDC->SetBackgroundMode (wxSOLID);
        m_memDC->SetTextBackground (m_currentBg);
        m_memDC->SetTextForeground (m_currentFg);
        break;
    case 2:         // erase
        m_memDC->SetBackgroundMode (wxTRANSPARENT);
        m_memDC->SetTextForeground (m_currentBg);
        break;
    case 3:         // write
        m_memDC->SetBackgroundMode (wxTRANSPARENT);
        m_memDC->SetTextForeground (m_currentFg);
        break;
    }
    
    m_memDC->GetTextExtent (chr, &m_fontwidth, &m_fontheight);

    x = XMADJUST (x);
    y = YMADJUST (BOUND (y + m_fontheight - 1));

    currentX += m_fontwidth;
    
    if (modexor)
    {
        m_memDC->SetLogicalFunction (wxXOR);
    }
    else
    {
        m_memDC->SetLogicalFunction (wxCOPY);
    }
    m_memDC->DrawText (chr, x, y);

#ifdef __WXMSW__
    // On Windows, the Alpha channel gets messed up by
    // the DrawText operation, which makes for very
    // strange looking displays.  So fix it.  It's a 
    // bit crude, but it gets the job done.
    fixAlpha ();
#endif
    m_memDC->SelectObject (wxNullBitmap);
}

/*--------------------------------------------------------------------------
**  Purpose:        Process word of PLATO output data
**
**  Parameters:     Name        Description.
**                  d           19-bit word
**                  ascii       true if using ASCII protocol
**
**  Returns:        true if the bitmap has changed, false otherwise.
**
**------------------------------------------------------------------------*/
bool PtermFrame::procPlatoWord (u32 d, bool ascii)
{
    mptr mp;
    const char *msg = "";
    int i, n = 0;
    AscState    ascState;
    bool changed = false;
    bool autobs;
    
    // used in load coordinate
    int &coord = (d & 01000) ? currentY : currentX;
    int &cx = (vertical) ? currentY : currentX;
    int &cy = (vertical) ? currentX : currentY;
    
    int deltax, deltay, supdelta;

    bool settitleflag = false;
    
    if (m_usefont && currentCharset <= 1)
    {
        supdelta = (m_fontheight / 3);
        // Not going to support reverse/vertical in font mode until I
        // get documentation on what worked with -font- in the past.
        // JWS 5/27/2007
        deltax = 8;
        deltay = m_fontheight;
    }
    else
    {
        deltax = (reverse) ? -8 : 8;
        deltay = (vertical) ? -16 : 16;
        if (large)
        {
            deltax *= 2;
            deltay *= 2;
        }
        supdelta = (deltay / 16) * 5;
    }
    
    seq++;
    m_currentWord = d;
    if (ascii)
    {
        if (m_dumbTty)
        {
            if (d == (033 << 8) + 002)   // ESC STX
            {
                trace ("Entering PLATO terminal mode");
                m_dumbTty = false;
                mode = (3 << 2) + 1;    // set character mode, rewrite
            }
            else if ((d >> 8) == 0)
            {
                changed = true;
                if (d >= 32 && d < 127)
                {
                    d = asciiM0[d];
                    if (d != 0xff)
                    {
                        // Force mode rewrite
                        mode = (3 << 2) + 1;
                        i = (d & 0x80) >> 7;
                        d &= 0x7f;
                        SaveChar (currentX, currentY, rom01char[d + i * 64],
                                  false);
                        ptermDrawChar (currentX, currentY, i, d);
                        currentX = (currentX + 8) & 0777;
                    }
                }
                else if (d == 015)
                {
                    currentX = 0;
                }
                else if (d == 012)
                {
                    if (currentY != 0)
                    {
                        currentY -= 16;
                    }
                    else
                    {
                        // On the bottom line... scroll both the
                        // display and the selection image bitmaps.
                        // And scroll the saved text map.  And cancel
                        // any selected region because the image
                        // scrolled out from under the region.  No,
                        // we're not going to adjust the region
                        // positions...
                        int row;
                        PixelData pixmap (*m_bitmap);
                        PixelData selmap (*m_selmap);

                        PixelData::Iterator from (pixmap);
                        PixelData::Iterator to (pixmap);
                        PixelData::Iterator sfrom (selmap);
                        PixelData::Iterator sto (selmap);

                        // We move row at a time because apparently on
                        // some OS (Windows) the rows are not
                        // contiguous.
                        for (row = 16; row < 512; row++)
                        {
                            from.MoveTo (pixmap, 0, row);
                            to.MoveTo (pixmap, 0, row - 16);
                            sfrom.MoveTo (selmap, 0, row);
                            sto.MoveTo (selmap, 0, row - 16);

                            memmove (to.m_ptr, from.m_ptr, 512 * 4);
                            memmove (sto.m_ptr, sfrom.m_ptr, 512 * 4);
                        }
                        
                        // Note that the textmap has y==0 for the bottom line
                        memmove (&textmap[64], &textmap[0],
                                 (sizeof (textmap) / 32) * 31);
                        memset (&textmap[0], 0, sizeof (textmap) / 32);

                        ClearRegion ();
                    }
                    // Erase the line we just moved to.
                    mode = (3 << 2) + 2;    // set character mode, erase
                    ptermBlockErase (0, currentY, 511, currentY + 15);
                    mode = (3 << 2) + 1;    // set character mode, rewrite
                }
            }
        }
        else if (m_ascState == pni_rs)
        {
            // We just want to ignore 3 command codes.  Note that escape
            // sequences count for one, not two.
            if (++m_ascBytes == 3)
            {
                m_ascBytes = 0;
                m_ascState = none;
            }
        }
        else if (m_ascState == pmd)
        {
            n = AssembleAsciiPlatoMetaData (d);
            if (n == 0)
            {
                if (m_fontPMD)
                {
                    trace ("plato meta data complete: font data accepted");
                    trace ("Font selected: %s, %d, %d",
                           m_fontface.mb_str ().data (), m_fontsize,
                           m_fontbold|m_fontitalic|m_fontstrike|m_fontunderln);
                    m_fontPMD = false;
                }
                else if (m_fontinfo)
                {
                    trace ("plato meta data complete: get font data accepted and sent");
                    m_fontinfo = false;
                }
                else if (m_osinfo)
                {
                    trace ("plato meta data complete: get operating system info accepted and sent");
                    m_osinfo = false;
                }
                else
                {
                    trace ("plato meta data complete: %s",
                           m_PMD.mb_str ().data ());
                    ProcessPlatoMetaData ();
                }
                m_PMD = wxT ("");
            }
        }
        else if ((d >> 8) == 033)
        {
            // Escape sequence, the second character is in the low byte
            d &= 0377;
            switch (d)
            {
            case 002:   // ESC STX
                trace ("Still in PLATO terminal mode");
                m_dumbTty = false;
                break;
            case 003:   // ESC ETX
                trace ("Leaving PLATO terminal mode");
                m_dumbTty = true;
                m_flowCtrl = false;
                m_sendFgt = false;
                currentX = 0;
                currentY = 496;
                break;
            case 014:   // ESC FF
                trace ("Full screen erase");
                ptermFullErase ();
                changed = true;
                break;
            case 026:
                // mode xor (also sets mode write for off-screen DC operations)
                trace ("load mode xor");
                modexor = true;
                mode = (mode & ~3) + 2;
                break;
            case 021:   // ESC DC1
            case 022:   // ESC DC2
            case 023:   // ESC DC3
            case 024:   // ESC DC4
                // modes inverse, write, erase, rewrite
                modexor = false;
                mode = (mode & ~3) + ascmode[d - 021];
                //mode = 017;
                trace ("load mode %d", mode);
                break;
            case '2':
                // Load coordinate
                trace ("Start load coordinate");
                m_ascState = ldc;
                m_ascBytes = 0;
                break;
            case '@':
                // superscript
                trace ("Superscript");
                cy = (cy + supdelta) & 0777;
                break;
            case 'A':
                // subscript
                trace ("Subscript");
                cy = (cy - supdelta) & 0777;
                break;
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
                trace ("select memory M%d", d - 'B');
                setCmem (d - 'B');
                break;
            case 'J':
                trace ("Horizontal writing mode");
                setVertical (false);
                break;
            case 'K':
                trace ("Vertical writing mode");
                setVertical (true);
                break;
            case 'L':
                trace ("Forward writing mode");
                setReverse (false);
                break;
            case 'M':
                trace ("Reverse writing mode");
                setReverse (true);
                break;
            case 'N':
                trace ("Normal size writing mode");
                setLarge (false);
                break;
            case 'O':
                trace ("Double size writing mode");
                setLarge (true);
                break;
            case 'P':
                modexor = false;
                mode = (mode & 3) + (2 << 2);
                trace ("load mode %d", mode);
                break;
            case 'Q':
                m_ascState = ssf;
                m_ascBytes = 0;
                trace ("Start SSF");
                break;
            case 'R':
                // external data
                m_ascState = ext;
                m_ascBytes = 0;
                trace ("Start ext");
                break;
            case 'S':
                modexor = false;
                mode = (mode & 3) + (2 << 2);
                trace ("load mode %d", mode);
                break;
            case 'T':
                modexor = false;
                mode = (mode & 3) + (5 << 2);
                trace ("load mode %d", mode);
                break;
            case 'U':
                modexor = false;
                mode = (mode & 3) + (6 << 2);
                trace ("load mode %d", mode);
                break;
            case 'V':
                modexor = false;
                mode = (mode & 3) + (7 << 2);
                trace ("load mode %d", mode);
                break;
            case 'W':
                // Load memory address
                trace ("Start LDA");
                m_ascState = lda;
                m_ascBytes = 0;
                break;
            case 'X':
                trace ("Start load plato meta data");
                m_ascState = pmd;
                m_ascBytes = 0;
                break;
            case 'Y':
                // load echo
                trace ("Start LDE");
                m_ascState = lde;
                m_ascBytes = 0;
                break;
            case 'Z':
                // set margin
                trace ("set margin %d", currentX);
                setMargin (cx);
                break;
            case 'a':
                // set foreground color
                trace ("Start foreground color");
                m_ascState = fg;
                m_ascBytes = 0;
                break;
            case 'b':
                // set background color
                trace ("Start background color");
                m_ascState = bg;
                m_ascBytes = 0;
                break;
            case 'c':
                // paint
                trace ("Start paint");
                m_ascState = paint;
                m_ascBytes = 0;
                break;
            case 'g':
                // set gray-scale foreground color
                trace ("Start grayscale foreground color");
                m_ascState = gsfg;
                m_ascBytes = 0;
                break;
            default:
                trace ("Other unknown ESCAPE sequence: %d", d);
                break;
            }
        }
        else
        {
            switch (d)
            {
            case 010:   // backspace
                cx = (cx - deltax) & 0777;
                trace ("backspace");
                break;
            case 011:   // tab
                trace ("tab");
                cx = (cx + deltax) & 0777;
                break;
            case 012:   // linefeed
                trace ("linefeed");
                cy = (cy - deltay) & 0777;
                break;
            case 013:   // vertical tab
                trace ("vertical tab");
                cy = (cy + deltay) & 0777;
                break;
            case 014:   // form feed
                trace ("form feed");
                if (vertical)
                {
                    cx = deltay - 1;
                    cy = reverse ? 512 - deltax : 0;
                }
                else
                {
                    cy = 512 - deltay;
                    cx = reverse ? 512 - deltax : 0;
                }
                break;
            case 015:   // carriage return
                cx = margin;
                cy = (cy - deltay) & 0777;
                trace ("CR to %d %d", currentX, currentY);
                break;
            case 031:   // EM
                mode = (mode & 3) + (4 << 2);
                modewords = 0;              // words since entering mode
                trace ("load mode %d", mode);
                break;
            case 034:   // FS
                mode = (mode & 3) + (0 << 2);
                trace ("load mode %d", mode);
                break;
            case 035:   // FS
                mode = (mode & 3) + (1 << 2);
                m_ascState = ldc; // to have first coordinate be "dark"
                trace ("load mode %d", mode);
                break;
            case 036:   // RS -- used by PNI in connect handshake
                m_ascState = pni_rs;
                trace ("pni start download, ignoring next 3 commands");
                break;
            case 037:   // FS
                mode = (mode & 3) + (3 << 2);
                trace ("load mode %d", mode);
                break;
            }
            if (d >= 040)
            {
                switch (m_ascState)
                {
                case ldc:
                    if (AssembleCoord (d))
                    {
                        currentX = lastX;
                        currentY = lastY;
                        trace ("load coordinate %d %d", currentX, currentY);
                    }
                    break;
                case paint:
                    n = AssemblePaint (d);
                    if (n != -1)
                    {
                        trace ("paint %03o", n);
                        changed = true;
                        ptermPaint (n);
                    }
                    break;
                case lde:
                    n = AssembleData (d);
                    if (n != -1)
                    {
                        n &= 0177;
                        switch (n)
                        {
                        case 0160:
                            // 160 is terminal type query
                            n = 0160 + ASCTYPE;
                            trace ("load echo termtype %d", n);
                            break;
                        case 0x71:
                            if (1) //(n = m_profile->m_termType) == -1)
                            {
                                n = SUBTYPE;
                            }
                            trace ("load echo subtype %d", n);
                            break;
                        case 0x72:
                            trace ("load echo loadfile (unused)");
                            n = 0;
                            break;
                        case 0x73:
                            // hex 73 is report terminal config
                            trace ("load echo termdata");
                            n = TERMCONFIG;
                            break;
                        case 0x7b:
                            // hex 7b is beep
                            if (m_beepEnable)
                            {
                                trace ("beep");
                                wxBell ();
                                if (!IsActive ())
                                {
                                    RequestUserAttention (wxUSER_ATTENTION_INFO);
                                }
                            }
                            break;
                        case 0x7d:
                            // hex 7d is report MAR
                            trace ("report MAR %o", memaddr);
                            n = memaddr;
                            break;
                        case 0x52:
                            // hex 52 is enable flow control
                            trace ("enable flow control");
                            m_flowCtrl = true;
                            n = 0x53;
                            break;
                        case 0x60:
                            // hex 60 is inquire features
                            trace ("report features 0x%02x", ASCFEATURES);
                            n += ASCFEATURES;
                            m_sendFgt = true;
                            break;
                        default:
                            trace ("load echo %d (0x%02x)", n, n);
                        }
                        if (n == 0x7b)
                        {
                            // -beep- does NOT send an echo code in reply
                            break;
                        }
                        if (m_conn == NULL)
                        {
                            // If no connection, don't try to reply
                            break;
                        }
                        
                        n += 0200;
                        if (m_conn->RingCount () > RINGXOFF1)
                        {
                            debug ("pend echo %d, previous was %d",
                                    n, m_pendingEcho);
                            m_pendingEcho = n;
                        }
                        else
                        {
                            ptermSendKey1 (n);
                            m_pendingEcho = -1;
                        }
                    }
                    break;
                case lda:
                    n = AssembleData (d);
                    if (n != -1)
                    {
                        trace ("load memory address %04x", n);
                        memaddr = n & 077777;
                    }
                    break;
                case ext:
                    trace ("ext %04x", d);
                    n = AssembleData (d);
                    switch (n)
                    {
                    case -1:
                        break;
                    // check for special TERM area save/restore
                    case CWS_TERMSAVE:
                        trace ("ext completed %04x", n);
                        // data items are, in order: xleft, ytop, xright, ybot
                        cwswindow[0].data[0] = 0;
                        cwswindow[0].data[1] = 48;
                        cwswindow[0].data[2] = 511;
                        cwswindow[0].data[3] = 0;
                        ptermSaveWindow (0);
                        break;
                    case CWS_TERMRESTORE:
                        trace ("ext completed %04x", n);
                        ptermRestoreWindow (0);
                        changed = true;
                        break;
                    default:
                        trace ("ext completed %04x", n);
                        // check if in cws mode
                        switch (cwsmode)
                        {
                            // not in cws; check for font data
                            case 0:
                                cwscnt = 0;
                                switch (n & 07700)
                                {
                                case 05000:     // font face name and family
                                    SetFontFaceAndFamily (n & 077);
                                    break;
                                case 05100:     // font size
                                    SetFontSize (n & 077);
                                    break;
                                case 05200:     // font flags
                                    SetFontFlags (n & 077);
                                    SetFontActive ();
                                    break;
                                }
                                break;
                            // check for cws data mode
                            case 1:
                                cwscnt++;
                                if     (cwscnt == 1 && n == CWS_SAVE)          
                                {
                                    trace ("CWS: specify save function");
                                    cwsfun = CWS_SAVE;
                                }
                                else if (cwscnt == 1 && n == CWS_RESTORE)   
                                {
                                    trace ("CWS: specify restore function");
                                    cwsfun = CWS_RESTORE;
                                }
                                else if (cwscnt == 1 || cwscnt > 6)
                                {
                                    // unknown function; terminate cws mode
                                    trace ("CWS: invalid function; %d", n);
                                    cwsmode = 0;
                                    cwsfun = 0;
                                    cwscnt = 0;
                                }
                                else if (cwscnt == 2)
                                {
                                    if ((unsigned) n < sizeof (cwswindow) / sizeof (cwswindow[0]))
                                    {
                                        trace ("CWS: specify window; %d", n);
                                        cwswin = n;
                                    }
                                    else
                                    {
                                        trace ("CWS: invalid window; %d", n);
                                        cwsmode = 0;
                                        cwsfun = 0;
                                        cwscnt = 0;
                                    }
                                }
                                else if (cwscnt < 7)
                                {
                                    trace ("CWS: data; %d", n);
                                    cwswindow[cwswin].data[cwscnt - 3] = n;
                                }
                                break;
                            // check for cws execute mode
                            case 2:
                                cwscnt = 0;
                                if (n == CWS_EXEC)
                                {
                                    trace ("CWS: process exec");
                                    switch (cwsfun)
                                    {
                                    case CWS_SAVE:
                                        ptermSaveWindow (cwswin);
                                        break;
                                    case CWS_RESTORE:
                                        ptermRestoreWindow (cwswin);
                                        changed = true;
                                        break;
                                    }
                                }
                                else
                                {
                                    // unknown function; terminate cws mode
                                    trace ("CWS: invalid function; %d", n);
                                    cwsmode = 0;
                                    cwsfun = 0;
                                    cwscnt = 0;
                                }
                                break;
                            }
                    }
                    break;
                case ssf:
                    n = AssembleData (d);
                    if (n != -1)
                    {
                        trace ("ssf %04x", n);
                        m_canvas->ptermTouchPanel ((n & 0x20) != 0);
                    }
                    switch (n)
                    {
                    case 0x1f00:    // xin 7; means start CWS functions
                        trace ("ssf; start cws mode; %04x", n);
                        cwsmode = 1;
                        break;
                    case 0x1d00:    // xout 7; means stop CWS functions
                        trace ("ssf; stop cws mode; %04x", n);
                        cwsmode = 2;
                        break;
                    case -1:
                        break;
                    default:
                        trace ("ssf %04x", n);
                        m_canvas->ptermTouchPanel ((n & 0x20) != 0);
                        break;
                    }
                    break;
                case fg:
                case bg:
                    ascState = m_ascState;
                    n = AssembleColor (d);
                    if (n != -1 && !m_noColor)
                    {
                        wxColour c ((n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff);
                        if (ascState == fg)
                        {
                            trace ("set foreground color %06x", n);
                            m_currentFg = c;
                        }
                        else
                        {
                            trace ("set background color %06x", n);
                            m_currentBg = c;
                        }
                        SetColors (m_currentFg, m_currentBg);
                    }
                    break;
                case gsfg:
                    ascState = m_ascState;
                    n = AssembleGrayScale (d);
                    if (n != -1 && !m_noColor)
                    {
                        wxColour c (n & 0xff, n & 0xff, n & 0xff);
                        if (ascState == gsfg)
                        {
                            trace ("set gray-scale foreground color %06x", n);
                            m_currentFg = c;
                        }
                        SetColors (m_currentFg, m_currentBg);
                    }
                    break;
                case pmd:
                    break; // handled above
                case none:
                    switch (mode >> 2)
                    {
                    case 0:
                        if (AssembleCoord (d))
                        {
                            mode0 ((lastX << 9) + lastY);
                            changed = true;
                        }
                        break;
                    case 1:
                        if (AssembleCoord (d))
                        {
                            mode1 ((lastX << 9) + lastY);
                            changed = true;
                        }
                        break;
                    case 2:
                        n = AssembleData (d);
                        if (n != -1)
                        {
                            mode2 (n);
                        }
                        break;
                    case 3: // text mode
                        trace ("char %03o (%c)", d, d);
                        m_ascState = none;
                        m_ascBytes = 0;
                        changed = true;
                        i = currentCharset;
                        if (m_usefont && i == 0)
                        {
                            SaveChar (currentX, currentY, d, large);
                            drawFontChar (currentX, currentY, d);
                        }
                        else
                        {
                            if (i == 0)
                            {
                                d = asciiM0[d];
                                // The ROM vs. RAM choice is given by the
                                // current character set.  
                                // For the ROM characters, the even vs. odd
                                // (M0 vs. M1) choice is given by the top bit
                                // of the ASCII translation table.
                                i = (d & 0x80) >> 7;
                            }
                            else if (i == 1)
                            {
                                d = asciiM1[d];
                                i = (d & 0x80) >> 7;
                            }
                            else
                            {
                                // RAM characters are indexed by printable
                                // ASCII characters; the RAM character offset
                                // is simply the character code - 32.
                                // The set choice is simply what the host sent.
                                d = (d - 040) & 077;
                            }
                            if (d != 0xff)
                            {
                                d &= 0x7f;
                                autobs = SaveChar (currentX, currentY,
                                                   rom01char[d + i * 64],
                                                   large);
                                ptermDrawChar (currentX, currentY, 
                                               i, d, autobs);
                                cx = (cx + deltax) & 0777;
                            }
                        }
                        break;
                    case 4:
                        if (AssembleCoord (d))
                        {
                            if (modewords & 1)
                            {
                                changed = true;
                            }
                            modewords++;
                            mode4 ((lastX << 9) + lastY);
                        }
                        break;
                    case 5:
                        n = AssembleData (d);
                        if (n != -1)
                        {
                            changed = true;     // assume changed for
                            mode5 (n);
                        }
                        break;
                    case 6:
                        n = AssembleData (d);
                        if (n != -1)
                        {
                            changed = true;     // assume changed for
                            mode6 (n);
                        }
                        break;
                    case 7:
                        n = AssembleData (d);
                        if (n != -1)
                        {
                            changed = true;     // assume changed for
                            mode7 (n);
                        }
                        break;
                    }
                    break;
                case pni_rs:
                    break;
                }
            }
        }
    }
    else
    {
        if ((d & NOP_MASK) == 0)
        {
            // NOP command...
            if (d & 1)
            {
                wc = (wc + 1) & 0177;
            }
        }
        else
        {
            wc = (wc + 1) & 0177;
        }
    
        if (d & 01000000)
        {
            const int dmode = mode >> 2;
            
            modewords++;
            mp = modePtr[dmode];
            (this->*mp) (d);
            // Modes 0, 1, 3, 4 change the screen.  Mode 5-7 we can't tell so
            // we assume it does.  So only mode 2 leaves "changed" untouched.
            changed |= dmode != 2;
        }
        else
        {
            switch ((d >> 15) & 7)
            {
            case 0:     // nop
                settitleflag = false;
                // special code to tell pterm the station number
                if ((d & NOP_MASKDATA) == NOP_SETSTAT)
                {
                    d &= 0777;
                    m_station.Printf ("%d-%d", d >> 5, d & 31);
                    ptermUpdateTitle ();
                }
                // special code to get font type / size / flags
                else if ((d & NOP_MASKDATA) == NOP_FONTTYPE)
                    SetFontFaceAndFamily (d & 077);
                else if ((d & NOP_MASKDATA) == NOP_FONTSIZE)
                    SetFontSize (d & 077);
                else if ((d & NOP_MASKDATA) == NOP_FONTFLAG)
                {
                    SetFontFlags (d & 077);
                    SetFontActive ();
                }
                else if ((d & NOP_MASKDATA) == NOP_FONTINFO)
                {
                    const int chardelay = m_charDelay;
                    ptermSendExt ((int) m_fontwidth);
                    wxMilliSleep (chardelay);
                    ptermSendExt ((int) m_fontheight);
                    wxMilliSleep (chardelay);
                }
                else if ((d & NOP_MASKDATA) == NOP_OSINFO)
                {
                    const int chardelay = m_charDelay;
                    // sends 3 external keys, OS, major version, minor version
                    int os, major, minor;
                    os = wxGetOsVersion (&major, &minor);
                    ptermSendExt (os);
                    wxMilliSleep (chardelay);
                    if (os == wxMAC || os == wxMAC_DARWIN)
                        ptermSendExt (10 * (major >> 4) + (major & 0x0f));
                    else
                        ptermSendExt (major);
                    wxMilliSleep (chardelay);
                    if (os == wxMAC || os == wxMAC_DARWIN)
                        ptermSendExt (10* (minor >> 4) + (minor & 0x0f));
                    else
                        ptermSendExt (minor);
                    wxMilliSleep (chardelay);
                }
                // otherwise check for plato meta data codes
                else
                {
                    if ((d & NOP_MASKDATA) == NOP_PMDSTART && !m_loadingPMD)
                    {
                        m_loadingPMD = true;
                        m_PMD = wxT ("");
                        settitleflag = AssembleClassicPlatoMetaData (d & 077);
                    }
                    else if ((d & NOP_MASKDATA) == NOP_PMDSTREAM && m_loadingPMD) 
                    {
                        settitleflag = AssembleClassicPlatoMetaData (d & 077);
                    }
                    else if ((d & NOP_MASKDATA) == NOP_PMDSTOP && m_loadingPMD)
                    {
                        m_loadingPMD = false;
                        AssembleClassicPlatoMetaData (d & 077);
                        settitleflag = true;
                    }
                    if (settitleflag)
                    {
                        ProcessPlatoMetaData ();
                    }
                }
                trace ("nop");
                break;

            case 1:     // load mode
                modewords = 0;              // words since entering mode
                if ((d & 020000) != 0)
                {
                    // load wc bit is set
                    wc = (d >> 6) & 0177;
                }
                modexor = false;
                mode = (d >> 1) & 037;
                if (d & 1)
                {
                    // full screen erase
                    ptermFullErase ();
                    changed = true;
                }
                trace ("load mode %d screen %d", mode, (d & 1));
                break;
            
            case 2:     // load coordinate
            
                if (d & 04000)
                {
                    // Add or subtract from current coordinate
                    if (d & 02000)
                    {
                        coord -= d & 0777;
                    }
                    else
                    {
                        coord += d & 0777;
                    }
                }
                else
                {
                    coord = d & 0777;
                }
        
                if (d & 010000)
                {
                    setMargin (coord);
                    msg = "margin";
                }
                trace ("load coord %c %d %s", (d & 01000) ? 'Y' : 'X',
                       d & 0777, msg);
                break;
            case 3:     // echo
                d &= 0177;
                switch (d)
                {
                case 0160:
                    // 160 is terminal type query
                    if ((d = m_profile->m_termType) == -1)
                    {
                        d = TERMTYPE;
                    }
                    trace ("load echo termtype %d", 0160 + d);
                    break;
                case 0x7b:
                    // hex 7b is beep
                    if (m_beepEnable)
                    {
                        trace ("beep");
                        wxBell ();
                        if (!IsActive ())
                        {
                            RequestUserAttention (wxUSER_ATTENTION_INFO);
                        }
                    }
                    break;
                case 0x7d:
                    // hex 7d is report MAR
                    trace ("report MAR %o", memaddr);
                    d = memaddr;
                    break;
                default:
                    trace ("load echo %d", d);
                }
                if (d == 0x7b)
                {
                    break;          // -beep- does NOT send an echo code in reply
                }
                if (m_conn == NULL)
                {
                    // If no connection, don't try to reply
                    break;
                }
                d += 0200;
                if (m_conn->RingCount () > RINGXOFF1)
                {
                    m_pendingEcho = d;
                }
                else
                {
                    ptermSendKey1 (d);
                    m_pendingEcho = -1;
                }
                break;
            
            case 4:     // load address
                memaddr = d & 077777;
                trace ("load address %o (0x%x)", memaddr, memaddr);
                break;
            
            case 5:     // SSF on PPT
                switch ((d >> 10) & 037)
                {
                case 1: // Touch panel control ?
                    trace ("ssf touch %o", d);
                    m_canvas->ptermTouchPanel ((d & 040) != 0);
                    break;
                default:
                    trace ("ssf %o", d);
                    break;  // ignore
                }
                break;

            case 6:
            case 7:
                d &= 0177777;
                trace ("Ext %07o", d);
                // Take no other action here -- it's been done already
                // when the word was fetched
                break;

            default:    // ignore
                trace ("ignored command word %07o", d);
                break;
            }
        }
    }
    m_currentWord = 0;
    
    return changed;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble a 9 bit data word for the ASCII protocol
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        -1 if word not complete yet, otherwise the word
**
**------------------------------------------------------------------------*/
int PtermFrame::AssemblePaint (int d)
{
    if (m_ascBytes == 0)
    {
        m_assembler = 0;
    }    
    m_assembler |= ((d & 077) << (m_ascBytes * 6));
    if (++m_ascBytes == 2)
    {
        m_ascBytes = 0;
        m_ascState = none;
        trace ("paint %03o (0x%04x)", m_assembler, m_assembler);
        return m_assembler;
    }
    else
    {
        trace ("paint byte %d: %d", m_ascBytes, d & 077);
    }
    return -1;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble an 18 bit data word for the ASCII protocol
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        -1 if word not complete yet, otherwise the word
**
**------------------------------------------------------------------------*/
int PtermFrame::AssembleData (int d)
{
    if (m_ascBytes == 0)
    {
        m_assembler = 0;
    }    
    m_assembler |= ((d & 077) << (m_ascBytes * 6));
    if (++m_ascBytes == 3)
    {
        m_ascBytes = 0;
        m_ascState = none;
        trace ("data %07o (0x%04x)", m_assembler, m_assembler);
        return m_assembler;
    }
    else
    {
        trace ("data byte %d: %d", m_ascBytes, d & 077);
    }
    return -1;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble a 24 bit color word for the ASCII protocol
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        -1 if word not complete yet, otherwise the color word
**
**------------------------------------------------------------------------*/
int PtermFrame::AssembleColor (int d)
{
    if (m_ascBytes == 0)
    {
        m_assembler = 0;
    }    
    m_assembler |= ((d & 077) << (m_ascBytes * 6));
    if (++m_ascBytes == 4)
    {
        m_ascBytes = 0;
        m_ascState = none;
        //trace ("color 0x%06x)", m_assembler);
        return m_assembler;
    }
    else
    {
        trace ("color byte %d: %d", m_ascBytes, d & 077);
    }
    return -1;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble an 7 bit grayscale word for the ASCII protocol
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        -1 if word not complete yet, otherwise the color word
**
**------------------------------------------------------------------------*/
int PtermFrame::AssembleGrayScale (int d)
{
    if (m_ascBytes == 0)
    {
        m_assembler = 0;
    }    
    m_assembler = (d & 077) << 2;
    if (++m_ascBytes == 1)
    {
        m_ascBytes = 0;
        m_ascState = none;
        trace ("gray-scale color 0x%06x", m_assembler);
        return m_assembler;
    }
    else
    {
        trace ("gray-scale color byte %d: %d", m_ascBytes, d & 0177);
    }
    return -1;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble a coordinate pair for the ASCII protocol
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        true if word is complete, false if not
**                  lastX and lastY are the x/y coordinate received
**
**------------------------------------------------------------------------*/
bool PtermFrame::AssembleCoord (int d)
{
    int c = d & 037;
    
    switch (d >> 5)
    {
    case 1: // High X or high Y
        if (m_ascBytes == 0)
        {
            // High Y
            trace ("high Y %d", c);
            lastY = (lastY & 037) | (c << 5);
            m_ascBytes = 2;
        }
        else
        {
            trace ("high X %d", c);
            lastX = (lastX & 037) | (c << 5);
        }
        break;
    case 2:
        lastX = (lastX & 0740) | c;
        m_assembler = (lastX << 16) + lastY;
        m_ascBytes = 0;
        m_ascState = none;
        trace ("low X %d, coordinates %d %d", c, lastX, lastY);
        return true;
    case 3:
        trace ("low Y %d", c);
        lastY = (lastY & 0740) | c;
        m_ascBytes = 2;
        break;
    }
    return false;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble a string for use as extended data from Plato
**                  sent in ASCII connection mode.  Could be meta data
**                  for setting window caption or could be font data, or
**                  other data someday.
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        -1 if word not complete yet, otherwise 0 and get the
**                     data from m_PlatoMetaData
**
**------------------------------------------------------------------------*/
int PtermFrame::AssembleAsciiPlatoMetaData (int d)
{
    int od = d;
    const int chardelay = m_charDelay;

    trace ("plato meta data: %d (counter=%d)", d, m_ascBytes+1);
    d &= 077;
    if (m_ascBytes==0)
        m_PMD = wxT ("");
    m_ascBytes++;
    // check for start font mode
    if (od=='F' && m_ascBytes==1)
        m_fontPMD = true;
    // check for request font character info
    else if (od=='f' && m_ascBytes==1)
    {
        m_fontinfo = true;
        m_ascBytes = 0;
        m_ascState = none;
        ptermSendExt ((int) m_fontwidth);
        wxMilliSleep (chardelay);
        ptermSendExt ((int) m_fontheight);
        wxMilliSleep (chardelay);
        return 0;
    }
    // check for request operating system info
    else if (od=='o' && m_ascBytes==1)
    {
        // sends 3 external keys, OS, major version, minor version
        int os, major, minor;
        os = wxGetOsVersion (&major, &minor);
        ptermSendExt (os);
        wxMilliSleep (chardelay);
        if (os==wxMAC || os==wxMAC_DARWIN)
            ptermSendExt (10* (major>>4) + (major &0x0f));
        else
            ptermSendExt (major);
        wxMilliSleep (chardelay);
        if (os==wxMAC || os==wxMAC_DARWIN)
            ptermSendExt (10* (minor>>4) + (minor &0x0f));
        else
            ptermSendExt (minor);
        wxMilliSleep (chardelay);
        m_osinfo = true;
        m_ascBytes = 0;
        m_ascState = none;
        return 0;
    }
    // check if in font mode
    else if (m_fontPMD && m_ascBytes==2)
    {
        SetFontFaceAndFamily (d);
        if (d==0)
        {
            m_ascBytes = 0;
            m_ascState = none;
            return 0;
        }
    }
    else if (m_fontPMD && m_ascBytes==3)
        SetFontSize (d);
    else if (m_fontPMD && m_ascBytes==4)
    {
        SetFontFlags (d);
        SetFontActive ();
        m_ascBytes = 0;
        m_ascState = none;
        return 0;
    }
    // check if done / full
    else if (d==0 || m_ascBytes==1001)
    {
        if (m_ascBytes==1001)
        {
            trace ("plato meta data limit reached: %d bytes", 1000);
        }
        m_ascBytes = 0;
        m_ascState = none;
        return 0;
    }
    // otherwise keep assembling
    else
    {
        if (d >= 1 && d <= 26)
        {
            m_PMD.Append ((char) ('a'+d-1), 1);
        }
        else if (d >= 27 && d <= 36)
        {
            m_PMD.Append ((char) ('0'+d-27), 1);
        }
        else if (d == 38)
        {
            m_PMD.Append ('-', 1);
        }
        else if (d == 40)
        {
            m_PMD.Append ('/', 1);
        }
        else if (d == 44)
        {
            m_PMD.Append ('=', 1);
        }
        else if (d == 45)
        {
            m_PMD.Append (' ', 1);
        }
        else if (d == 63)
        {
            m_PMD.Append (';', 1);
        }
    }
    return -1;
}

/*--------------------------------------------------------------------------
**  Purpose:        Assemble a string for use as frame caption from data
**                  sent in Classic connection mode.
**
**  Parameters:     Name        Description.
**                  d           current byte of input
**
**  Returns:        -1 
**
**------------------------------------------------------------------------*/
bool PtermFrame::AssembleClassicPlatoMetaData (int d)
{
    trace ("plato meta data: %d", d);
    if (m_PMD.Len ()==1000)
    {
        trace ("plato meta data limit reached: 1000 bytes");
        m_loadingPMD = false;
        return true;
    }
    else
    {
        d &= 077;
        if (d >= 1 && d <= 26)
        {
            m_PMD.Append ((char) ('a'+d-1), 1);
        }
        else if (d >= 27 && d <= 36)
        {
            m_PMD.Append ((char) ('0'+d-27), 1);
        }
        else if (d == 38)
        {
            m_PMD.Append ('-', 1);
        }
        else if (d == 40)
        {
            m_PMD.Append ('/', 1);
        }
        else if (d == 44)
        {
            m_PMD.Append ('=', 1);
        }
        else if (d == 45)
        {
            m_PMD.Append (' ', 1);
        }
        else if (d == 63)
        {
            m_PMD.Append (';', 1);
        }
    }
    return false;
}

/*--------------------------------------------------------------------------
**  Purpose:        Change frame title to string specified in the assembled
**                  meta data.
**
**  Parameters:     none
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::ProcessPlatoMetaData ()
{
    int fnd;
    int len;

    len = m_PMD.Len ();

    //collect meta data items
    if ((fnd = m_PMD.Find (wxT ("name="))) != -1)
    {
        m_name = m_PMD.Mid (fnd + 5, len - fnd - 5);
        m_name = m_name.BeforeFirst (wxT (';'));
    }

    if ((fnd = m_PMD.Find (wxT ("group="))) != -1)
    {
        m_group = m_PMD.Mid (fnd + 6, len - fnd - 6);
        m_group = m_group.BeforeFirst (wxT (';'));
    }

    if ((fnd = m_PMD.Find (wxT ("system="))) != -1)
    {
        m_system = m_PMD.Mid (fnd + 7, len - fnd - 7);
        m_system = m_system.BeforeFirst (wxT (';'));
    }

    if ((fnd = m_PMD.Find (wxT ("station="))) != -1)
    {
        m_station = m_PMD.Mid (fnd + 8, len - fnd - 8);
        m_station = m_station.BeforeFirst (wxT (';'));
    }

    // Now update the title bar based on what we just collected
    ptermUpdateTitle ();
}

/*--------------------------------------------------------------------------
**  Purpose:        Update frame title based on received metadata
**
**  Parameters:     none
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermUpdateTitle ()
{
    wxString l_str;
    
    //make title string based on flags
    l_str = wxT ("");
    if (m_profile->m_showSignon && m_name != wxT ("") && m_group != wxT (""))
    {
        l_str = m_name;
        l_str.Append (wxT ("/"));
        l_str += m_group;

        // Show system name only as part of user/group
        if (m_profile->m_showSysName && m_system != wxT (""))
        {
            l_str.Append (wxT ("/"));
            l_str += m_system;
        }
    }
    
    if (m_profile->m_showHost && m_conn->ConnType () == HOST)
    {
        l_str.Append (wxT (" "));
        l_str += m_profile->m_host;
    }
    if (m_profile->m_showStation && m_station != wxT (""))
    {
        l_str.Append (wxT (" ("));
        l_str += m_station;
        l_str.Append (wxT (")"));
    }
    l_str.Trim (true);
    l_str.Trim (false);
    if (l_str.IsEmpty ())
    {
        l_str = wxT ("Pterm");
    }
    SetTitle (l_str);
}


/*--------------------------------------------------------------------------
**  Purpose:        Set font face name and family flag.
**
**  Parameters:     font type code
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::SetFontFaceAndFamily (int n)
{
    switch (n)
    {
    case 2:
        m_fontface = wxT ("Terminal");
        m_fontfamily = wxFONTFAMILY_TELETYPE;
        break;
    case 3:
        m_fontface = wxT ("UOL8X14");
        m_fontfamily = wxFONTFAMILY_TELETYPE;
        break;
    case 4:
        m_fontface = wxT ("UOL8X16");
        m_fontfamily = wxFONTFAMILY_TELETYPE;
        break;
    case 5:
        m_fontface = wxT ("Courier");
        m_fontfamily = wxFONTFAMILY_TELETYPE;
        break;
    case 6:
        m_fontface = wxT ("Courier New");
        m_fontfamily = wxFONTFAMILY_MODERN;
        break;
    case 16:
        m_fontface = wxT (SSFONT);
        m_fontfamily = wxFONTFAMILY_DECORATIVE;
        break;
    case 17:
        m_fontface = wxT ("Times New Roman");
        m_fontfamily = wxFONTFAMILY_ROMAN;
        break;
    case 18:
        m_fontface = wxT ("Script");
        m_fontfamily = wxFONTFAMILY_SCRIPT;
        break;
    case 19:
        m_fontface = wxT ("MS Sans Serif");
        m_fontfamily = wxFONTFAMILY_SWISS;
        break;
    default:
        m_fontface = wxT ("default");
        m_fontfamily = wxFONTFAMILY_TELETYPE;
    }
}

/*--------------------------------------------------------------------------
**  Purpose:        Set font size.
**
**  Parameters:     font size
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::SetFontSize (int n)
{
    m_fontsize = (n < 1 ? 1 : (n > 63 ? 63 : n));
}

/*--------------------------------------------------------------------------
**  Purpose:        Set font flags.
**
**  Parameters:     font flag
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::SetFontFlags (int n)
{
    m_fontitalic = ((n & 0x01) != 0);
    m_fontbold = ((n & 0x02) != 0);
    m_fontstrike = ((n & 0x04) != 0);
    m_fontunderln = ((n & 0x08) != 0);
    trace ("Font selected: %s, %d, %d", m_fontface.mb_str ().data (), m_fontsize, n & 0x0f);
}

/*--------------------------------------------------------------------------
**  Purpose:        Set font.
**
**  Parameters:     none
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::SetFontActive ()
{
    m_usefont = (m_fontface.Cmp (wxT (""))!=0 && m_fontface.Cmp (wxT ("default"))!=0);
    if (m_usefont)
    {
        wxFontInfo fi;
        
        fi.FaceName (m_fontface);
        fi.Family (m_fontfamily);
        fi.AntiAliased (true);
        fi.Bold (m_fontbold);
        fi.Italic (m_fontitalic);
        fi.Underlined (m_fontunderln);
        fi.Strikethrough (m_fontstrike);
        
        m_font = new wxFont (fi);
        // Set size in pixels (not points), height is supplied, width defaulted
        m_font->SetPixelSize (wxSize (0, m_fontsize));
        
        // We need to select a bitmap into the memDC for GetTextExtent
        // to be accepted.
        m_memDC->SelectObject (*m_bitmap);
        m_memDC->SetFont (*m_font);
        m_memDC->GetTextExtent (wxT (" "), &m_fontwidth, &m_fontheight);
        m_memDC->SelectObject (wxNullBitmap);
    }
}

/*--------------------------------------------------------------------------
**  Purpose:        Save a screen "window"
**
**  Parameters:     Name        Description.
**                  d           window number (range checked by caller)
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermSaveWindow (int d)
{
    wxBitmap *bm = new wxBitmap (512, 512, 32);
    wxMemoryDC dc (*bm);

    // We'll just copy the whole screen worth of bitmap, at restore time
    // we'll do a selective restore.  Note that just constructing a wxBitmap
    // with the copy constructor doesn't work, that gives us a reference to
    // the other bitmap.  We actually have to copy the data, which Blit does
    // easily.
    trace ("CWS: process save; window %d", d);
    cwswindow[d].ok = true;
    m_memDC->SelectObject (*m_bitmap);
    dc.Blit (0, 0, 512, 512, m_memDC, 0, 0);
    m_memDC->SelectObject (wxNullBitmap);
    cwswindow[d].bm = bm;
}

/*--------------------------------------------------------------------------
**  Purpose:        Restore a screen "window"
**
**  Parameters:     Name        Description.
**                  d           window number (range checked by caller)
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermRestoreWindow (int d)
{
    int x, y, w, h;

    x = XMADJUST (BOUND (cwswindow[d].data[0]));
    y = YMADJUST (BOUND (cwswindow[d].data[1]));
    w = BOUND (cwswindow[d].data[2] - cwswindow[d].data[0]);
    h = BOUND (cwswindow[d].data[1] - cwswindow[d].data[3]);
    if (cwswindow[d].ok)
    {
        trace ("CWS: process restore; window %d, region %d %d %d %d",
               d, x, y, w, h);
        m_memDC->SelectObject (*m_bitmap);
        // Blit would seem like a logical way to do this, but for some
        // reason it hits an Assert on Windows because some (but not all!)
        // of the bitmaps are missing the Alpha channel.  This in spite
        // of the fact that depth 32 is explicitly requested and the
        // documentation says that it is available.  So use DrawBitmap
        // instead, since that does work.
        m_memDC->SetClippingRegion (x, y, w, h);
        m_memDC->DrawBitmap (*cwswindow[d].bm, 0, 0, false);
        m_memDC->SelectObject (wxNullBitmap);

        cwswindow[d].ok = false;
        delete cwswindow[d].bm;
        cwswindow[d].bm = NULL;
    }
}

/*--------------------------------------------------------------------------
**  Purpose:        Write a trace message.
**
**  Parameters:     message
**
**  Returns:        nothing
**
**------------------------------------------------------------------------*/
void PtermFrame::WriteTraceMessage (wxString msg)
{
    trace ("%s", msg.mb_str ().data ());
    return;
}

/*--------------------------------------------------------------------------
**  Purpose:        Display visual indication of trace status
**
**  Parameters:     Name        Description.
**                  trace       new trace state (true for on)
**
**  Returns:        nothing
**
**  This function opens or flushes the trace file depending on trace
**  setting.  It then redraws (on or off) the trace indication.
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermSetTrace (bool trace)
{

    m_MtTrace = trace;
    if (!trace)
    {
        // Turning trace off
        tracex ("Trace off");
        traceF.Close ();
        tracePterm = trace;
    }
    else
    {
        // Turning trace on
        tracePterm = trace;
        traceF.Open (ptermApp->traceFn);
        if (m_mtutorBoot)
        {
            tracex("Trace on, locally booted");
        }
        else if (m_conn->Ascii ())
        {
            tracex ("Trace on, ASCII terminal");
        }
        else
        {
            tracex ("Trace on, Classic terminal");
        }
    }

    ptermShowTrace ();
}

/*
**--------------------------------------------------------------------------
**
**  Private Functions
**
**--------------------------------------------------------------------------
*/

/*--------------------------------------------------------------------------
**  Purpose:        Draw one character
**
**  Parameters:     Name        Description.
**                  c           Character code
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::plotChar (int c)
{
    int &cx = (vertical) ? currentY : currentX;
    int &cy = (vertical) ? currentX : currentY;
    
    int deltax, deltay, supdelta;
    bool autobs;
    
    if (m_usefont && currentCharset <= 1)
    {
        supdelta = (m_fontheight / 3);
        // Not going to support reverse/vertical in font mode until I
        // get documentation on what worked with -font- in the past.
        // JWS 5/27/2007
        deltax = 8;
        deltay = m_fontheight;
    }
    else
    {
        deltax = (reverse) ? -8 : 8;
        deltay = (vertical) ? -16 : 16;
        if (large)
        {
            deltax *= 2;
            deltay *= 2;
        }
        supdelta = (deltay / 16) * 5;
    }
    
    // check for uncover code and fast exit
    c &= 077;
    if (c == 077)
    {
        setUncover (true);
        return;
    }

    if (uncover)
    {
        setUncover (false);
        switch (c)
        {
        case 010:   // backspace
            cx = (cx - deltax) & 0777;
            break;
        case 011:   // tab
            cx = (cx + deltax) & 0777;
            break;
        case 012:   // linefeed
            cy = (cy - deltay) & 0777;
            break;
        case 013:   // vertical tab
            cy = (cy + deltay) & 0777;
            break;
        case 014:   // form feed
            if (vertical)
            {
                cx = deltay - 1;
                if (reverse)
                {
                    cy = 512 - deltax;
                }
                else
                {
                    cy = 0;
                }
            }
            else
            {
                cy = 512 - deltay;
                if (reverse)
                {
                    cx = 512 - deltax;
                }
                else
                {
                    cx = 0;
                }
            }
            break;
        case 015:   // carriage return
            cx = margin;
            cy = (cy - deltay) & 0777;
            break;
        case 016:   // superscript
            cy = (cy + supdelta) & 0777;
            break;
        case 017:   // subscript
            cy = (cy - supdelta) & 0777;
            break;
        case 020:   // select M0
        case 021:   // select M1
        case 022:   // select M2
        case 023:   // select M3
        case 024:   // select M4
        case 025:   // select M5
        case 026:   // select M6
        case 027:   // select M7
            setCmem (c - 020);
            break;
        case 030:   // horizontal writing
            setVertical (false);
            break;
        case 031:   // vertical writing
            setVertical (true);
            break;
        case 032:   // forward writing
            setReverse (false);
            break;
        case 033:   // reverse writing
            setReverse (true);
            break;
        case 034:   // normal size writing
            setLarge (false);
            break;
        case 035:   // double size writing
            setLarge (true);
            break;
        default:
            break;
        }
    }
    else
    {
        const wxChar ch = rom01char[c + 64 * currentCharset];
        
        if (m_usefont && currentCharset <= 1)
        {
            SaveChar (currentX, currentY, ch, large);
            drawFontChar (currentX, currentY, ch);
        }
        else
        {
            autobs = SaveChar (currentX, currentY, ch, large);
            ptermDrawChar (currentX, currentY, currentCharset, c, autobs);
            cx = (cx + deltax) & 0777;
        }
    }
}


/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 0 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode0 (u32 d)
{
    int x, y;
    
    x = (d >> 9) & 0777;
    y = d & 0777;
    trace ("dot %d %d", x, y);
    ptermDrawPoint (x, y);
    currentX = x;
    currentY = y;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 1 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode1 (u32 d)
{
    int x, y;
    
    x = (d >> 9) & 0777;
    y = d & 0777;
    trace ("lineto %d %d", x, y);
    ptermDrawLine (currentX, currentY, x, y);
    currentX = x;
    currentY = y;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 2 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode2 (u32 d)
{
    int chaddr;

    // Store the word in PPT RAM
    WriteRAM (memaddr, d);
    WriteRAM (memaddr + 1, d >> 8);

    // memaddr is a PPT RAM address; convert it to a character memory address
    chaddr = memaddr - ReadRAMW (C2ORIGIN);
    if (chaddr < 0 || chaddr > 127 * 16)
    {
        trace ("memdata %04x to %04x", d & 0xffff, memaddr);
    }
    else
    {
        chaddr /= 2;
        if (((d >> 16) & 3) == 0)
        {
            // load data
            trace ("character memdata %06o to char word %04o", d & 0xffff, chaddr);
            plato_m23[chaddr] = d & 0xffff;
            ++chaddr;
        }
    }
    memaddr += 2;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 3 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode3 (u32 d)
{
    if (traceF.Active ())
    {
        wxString t;
    
        t.Printf ("char %02o %02o %02o (", (d >> 12) & 077, 
                  (d >> 6) & 077, d & 077);
        t.Append (rom01char[(d >> 12) & 077]);
        t.Append (rom01char[(d >> 6) & 077]);
        t.Append (rom01char[d & 077]);
        t.Append (")");
        trace (t);
    }
    
    plotChar (d >> 12);
    plotChar (d >> 6);
    plotChar (d);
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 4 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode4 (u32 d)
{
    int x1, y1, x2, y2;
    
    if (modewords & 1)
    {
        trace ("block erase first word");
        mode4start = d;
        return;
    }
    x1 = (mode4start >> 9) & 0777;
    y1 = mode4start & 0777;
    x2 = (d >> 9) & 0777;
    y2 = d & 0777;
    
    trace ("block erase %d %d to %d %d", x1, y1, x2, y2);

    ptermBlockErase (x1, y1, x2, y2);
    m_ignoreDelay = true;      // Ignore any NOPs supplied by framat
    currentX = x1;
    currentY = y1 - 15;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 5 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode5 (u32 d)
{
    if (m_MReturnz80.IsRunning())
        m_MReturnz80.Stop();

    trace ("mode5 %06o", d);

    // Load C/D/E with data word
    state->registers.byte[Z80_C] = d >> 16;
    state->registers.byte[Z80_D] = d >> 8;
    state->registers.byte[Z80_E] = d;

    //printf("mode 5: c=%02x,  d=%02x, e=%02x\n", state->registers.byte[Z80_C], state->registers.byte[Z80_D], state->registers.byte[Z80_E]);

    if (!(((state->registers.byte[Z80_C] & 3) == 0) && (state->registers.byte[Z80_D] > 0)))
    {
        progmode(d, M5ORIGIN);
        return;
    }

    //// Push the return address onto the
    //// stack, as if we just did a CALL instruction
    WriteRAM(--state->registers.word[Z80_SP], ((state->pc) >> 8) & 0xff);
    WriteRAM(--state->registers.word[Z80_SP], (state->pc) & 0xff);

    // Set the start PC for the requested mode
    state->pc = ReadRAMW(M5ORIGIN);

    MicroEmulate;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 6 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
** THIS IS AN INTERRUPT!  STATE MUST BE SAVED AND RESTORED!!
** BUT THE z80 RET INSTRUCTIONS WILL NOT RETURN HERE!!
** z80 WILL JUST CONTINUE TO RUN.  BUT IT WILL NO LONGER
** BE DOING THE RIGHT THINGS.  OR ONLY ALLOW THIS TO BE CALLED
** WHEN EMULATOR IS EXPECTING ALL REGS TO BE CLOBBERED --> R.EXEC
**------------------------------------------------------------------------*/
void PtermFrame::mode6 (u32 d)
{
    if (m_MReturnz80.IsRunning())
        m_MReturnz80.Stop();

    trace ("mode6 %06o", d);
                        // Load C/D/E with data word
    u8 c = d >> 16;
    u8 d1 = d >> 8;
    u8 e = d;

    state->registers.byte[Z80_C] = c;
    state->registers.byte[Z80_D] = d1;
    state->registers.byte[Z80_E] = e;
    //// Push the return address onto the
    //// stack, as if we just did a CALL instruction
    WriteRAM(--state->registers.word[Z80_SP], ((state->pc) >> 8) & 0xff);
    WriteRAM(--state->registers.word[Z80_SP], (state->pc) & 0xff);

    // Set the start PC for the requested mode
    state->pc = ReadRAMW(M6ORIGIN);
    MicroEmulate;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 7 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::mode7 (u32 d)
{
    trace ("mode7 %06o", d);
    progmode (d, M7ORIGIN);
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Mode 5/6/7 data word
**
**  Parameters:     Name        Description.
**                  d           Data word
**                  origin      Address of mode handler pointer
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::progmode (u32 d, int origin)
{
    // Load C/D/E with data word
    state->registers.byte[Z80_C] = d >> 16;
    state->registers.byte[Z80_D] = d >> 8;
    state->registers.byte[Z80_E] = d;

    // Initialize the stack
    state->registers.word[Z80_SP] = INITSP;

    // Push the fake return address for "return to main loop" onto the
    // stack, as if we just did a CALL instruction
    WriteRAM (--state->registers.word[Z80_SP], R_MAIN >> 8);
    WriteRAM (--state->registers.word[Z80_SP], R_MAIN);

    // Set the start PC for the requested mode
    state->pc = ReadRAMW (origin);
    MicroEmulate;
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Plato mode keyboard input
**
**  Parameters:     Name        Description.
**                  keys        Plato key codes for station (see KEY macro)
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermSendKey (u32 keys)
{
    int i, key;
    
    if (IgnoreKeys())
    {
        return;
    }

    for (i = 0; i < 32; i += 8)
    {
        key = (keys >> i) & 0xff;
        if (key != (None & 0xff))
        {
            ptermSendKey1 (key);
        }
    }
}


// give resident RESIDENTMSEC ms before resuming 8080 exec
void PtermFrame::Mz80Waiter(int msec)
{
    m_MReturnz80.StartOnce(msec);
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Plato mode keyboard input
**
**  Parameters:     Name        Description.
**                  key         Plato key code for station
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermSendKey1 (int key)
{
    char data[5];
    int len;
    bool isStop1 = (key == 0x3a);

    if (!m_Mclock.IsRunning())
    {
        m_Mclock.Start(17);
    }
    if (!m_Dclock.IsRunning())
    {
        m_Dclock.Start(1000);
    }
    if (IgnoreKeys())
    {
        return;
    }

    tracex ("key to plato %03o", key);
    debug ("key to plato %03o", key);

    if (key2mtutor || m_mtutorBoot || m_conn->Ascii ())
    {
        // Assume one byte key code
        len = 1;
        if (key < 0200)
        {
            // Regular keyboard key
            key = asciiKeycodes[key];
            if (key == 0xff)
            {
                return;
            }
            if (m_flowCtrl && !key2mtutor)
            {
                // Do the keycode translation for the
                // "flow control enabled" coding rules.
                switch (key)
                {
                case 0x00:              // access
                    key = 0x1d;
                    len = 2;
                    break;
                case 0x05:              // shift-sub
                    key = 0x04;
                    len = 2;
                    break;
                case 0x0a:              // tab
                    key = 0x09;
                    break;
                case 0x09:              // shift-help
                    key = 0x0a;
                    break;
                case 0x11:              // shift-stop
                    key = 0x05;
                    break;
                case 0x17:              // shift-super
                    len = 2;
                    // fall through
                case 0x13:              // super
                    key = 0x17;
                    break;
                case 0x7c:              // apostrophe
                    key = 0x27;
                    break;
                case 0x27:              // #
                    key = 0x7c;
                    break;
                }
                data[0] = 033;          // store esc for 2 byte codes
            }                        
            data[len - 1] = Parity (key);

            if (!key2mtutor)
            {
                if (!m_mtutorBoot)   
                {
                    if (tracePterm)
                    {
                        if (len == 1)
                        {
                            tracex("ascii mode key to plato 0x%02x",
                                data[0] & 0xff);
                        }
                        else
                        {
                            tracex("ascii mode key to plato 0x%02x 0x%02x",
                                data[0], data[1] & 0xff);
                        }
                    }
                    m_conn->SendData(data, len);
                    if (m_dumbTty)
                    {
                        // do local echoing
                        m_conn->StoreWord(key);
                    }
                }
            }
            else
            {
                // do mtutor zkey conversion
                key = (key < 0x80) ? mtutorcvt[key & 0x7f] : key;
                if (tracePterm)
                {
                    tracex("key to mtutor 0x%02x", key);
                }

                if (m_lastKey == key && key == 0x3a)
                {
                    m_lastKey = -1;
                    return;     // de-bounce stop1
                }
                m_lastKey = key;
                mt_key = key;
                if (isStop1)
                {
                    len = 1;
                    data[0] = Parity(5);
                    m_conn->SendData (data, len);
                }
            }
        }
        else if (!m_dumbTty)
        {
            if (key == xofkey)
            {
                if (!m_flowCtrl)
                {
                    return;
                }
                data[0] = Parity (ascxof);
                tracex ("ascii mode key to plato XOFF");
            }
            else if (key == xonkey)
            {
                if (!m_flowCtrl)
                {
                    return;
                }
                data[0] = Parity (ascxon);
                tracex ("ascii mode key to plato XON");
            }
            else
            {
                len = 3;
                data[0] = 033;
                data[1] = Parity (0100 + (key & 077));
                data[2] = Parity (0140 + (key >> 6));
                tracex ("ascii mode key to plato 0x%02x 0x%02x 0x%02x", 
                        data[0] & 0xff, data[1] & 0xff, data[2] & 0xff);
            }
            if (!m_mtutorBoot)
                m_conn->SendData(data, len);
            else if (key > 0x0ff)
                mt_key = key;  // touch/ext?
        }
        else if ((key2mtutor) && key > 0x0ff)
            mt_key = key;  // touch/ext?
    }
    else
    {
        if (!key2mtutor)
        {
            data[0] = key >> 7;
            data[1] = 0200 | key;
            m_conn->SendData(data, 2);
        }
        else
        {
            if (tracePterm)
            {
                tracex("key to mtutor 0x%02x", key);
            }
            mt_key = key;
        }
    }
}

/*--------------------------------------------------------------------------
**  Purpose:        Process Plato mode keyboard input (multiple keys)
**
**  Parameters:     Name        Description.
**                  key         Array of integers of Plato key codes
**
**  Returns:        Nothing.
**
**------------------------------------------------------------------------*/
void PtermFrame::ptermSendKeys (const int key[])
{
    for (int i = 0; key[i] != -1; i++)
    {
        ptermSendKey1 (key[i]);
        m_pasteTimer.Start (m_charDelay, true);
    }
}
            
void PtermFrame::ptermSendTouch (int x, int y)
{
    char data[6];

    if (IgnoreKeys ())
    {
        return;
    }

    if (m_sendFgt)
    {
        // Send fine grid touch code first
        data[0] = 033;
        data[1] = 0x1f;
        data[2] = 0x40 + (x & 0x1f);
        data[3] = 0x40 + ((x >> 5) & 0x0f);
        data[4] = 0x40 + (y & 0x1f);
        data[5] = 0x40 + ((y >> 5) & 0x0f);
        m_conn->SendData (data, 6);
    }
    
    x /= 32;
    y /= 32;

    ptermSendKey1 (0x100 | (x << 4) | y);
}

void PtermFrame::ptermSendExt (int key)
{
    char data[3];

    if (m_conn == NULL)
    {
        return;
    }

    if (m_conn->Ascii ())
    {
        // Send external key
        data[0] = 033;
        data[1] = 0x40 | (key & 0x3f);
        data[2] = 0x68 | ((key >> 6) & 0x03);
        m_conn->SendData (data, 3);
    }
    else
    {
        data[0] = 0x04 | ((key >> 7) & 0x01);
        data[1] = 0x80 | (key & 0x7f);
        m_conn->SendData (data, 2);
    }
    
}

#if 0
int PtermFrame::Parity (int key)
{
    int i;
    int p = 0;
    key &= 0177;
    for (i = 0; i < 8; i++)
    {
        if (key & (1 << i))
        {
            p ^= 0200;
        }
    }
    return key; // | p;
}
#endif

void PtermFrame::ptermSetConnected ()
{
    // This routine is called when connection is initially made, or
    // when the statusbar is rebuilt.  See ProcessPlatoMetaData for
    // the dynamic code.
    wxString l_str;

    SetCursor (wxNullCursor);

    if (m_conn->ConnType () == HOST)
        l_str.Printf ("%s ", m_profile->m_host);
    if (HasConnection ())
    {
        if (m_conn->Ascii ())
        {
            l_str.Append (_("ASCII"));
        }
        else if (m_conn->Classic ())
        {
            l_str.Append (_("Classic"));
        }
    }
    ptermSetStatus (l_str);
}

void PtermFrame::ptermShowTrace ()
{
    if (m_statusBar != NULL)
    {
        if (tracePterm)
        {
            m_statusBar->SetStatusText (m_MTFiles[0].rwflag 
                + m_MTFiles[1].rwflag
                + _(" Trace | ")
                + m_profile->m_profileName, STATUS_TRC);
        }
        else if (m_conn != NULL && m_conn->GswActive ())
        {
            // Display a musical note.
            m_statusBar->SetStatusText (m_MTFiles[0].rwflag 
                + m_MTFiles[1].rwflag
                + wxT ("\u266C | ")
                + m_profile->m_profileName, STATUS_TRC);
        }
        else if (m_platoKb)
        {
            m_statusBar->SetStatusText (m_MTFiles[0].rwflag 
                + m_MTFiles[1].rwflag
                + _(" PLATO keyboard | ")
                + m_profile->m_profileName, STATUS_TRC);
        }
        else
        {
            m_statusBar->SetStatusText (m_MTFiles[0].rwflag 
                + m_MTFiles[1].rwflag
                + wxT (" ") +
                m_profile->m_profileName, STATUS_TRC);
        }
    }
}

// Save a character into the character map used for text copy.
// Returns True if this character is an auto-backspaced accent.
bool PtermFrame::SaveChar (int x, int y, wxChar c, bool large_p)
{
    static int prevx = -100, prevy = -100;
    const int cx = (vertical) ? y : x;
    const int cy = (vertical) ? x : y;
    const int px = (vertical) ? prevy : prevx;
    const int py = (vertical) ? prevx : prevy;
    const int size = (large) ? 2 : 1;
    const int savex = x, savey = y;
    int dx, dy, i;
    bool autobs = false;
    
#if 0
    wxString s;
    
    s.Printf ("saving at %d, %d, mode %d: %x: ", x, y, wemode, (int) c);
    s.Append (c);
    trace (s);
#endif
    dx = cx - px;
    dy = cy - py;

    // Mode erase means we're erasing a character, so set the saved character
    // to empty (space).
    if (wemode == 2)             // mode erase
    {
        c = ' ';
    }
    // Check for autobackspace BEFORE rounding the x/y position down
    // to the text grid (coarse grid) boundaries.  Note that 
    // auto-backspace is defined in terms of the current writing direction.
    // Also, it's only auto-backspace if the current writing mode is
    // write.
    else if (wemode == 3 &&     // mode write
        (dx == 0 || dx == 4 * size) &&
        dy >= -10 * size && 
        dy <= 11 * size)
    {
        // Mode and coordinates look like it might be an autobackspace.
        // So assume it is, and save this character accordingly as the
        // second or (occasionally) third character of a sequence.
        // The actual mapping of such sequences to the correct code is
        // done when we fetch the text from the selected region, e.g., 
        // for a "Copy text" operation.
        
        // dx == 4 applies only to the ae and AE ligatures.  Conversely,
        // there are no dx == 0 combinations that have e or E as the
        // second character.
        if (c == 'e' || c == 'E')
        {
            autobs = (dx == 4 * size);
        }
        else
        {
            autobs = (dx == 0);
        }
            
        // Convert an accent character to its "combining diacritical" form.
        i = accent.find (c);
        if (i != (int)wxString::npos)
        {
            c = combining_accent[i];
        }
        if (c == L'\u0301')
        {
            // Acute accent.  If dy is negative, that's actually a cedilla
            // (on classic).
            if (dy < 0)
            {
                c = L'\u0327';
            }
        }
    }
            
    // Convert the current x/y to a coarse grid position, and save
    // the current character into the textmap array.
    // Note that the Y coordinate starts with 0 for the bottom
    // line, just as the fine grid Y coordinate does.
    // The X/Y are taken from the previous X/Y if we're doing autobackspace,
    // otherwise we might end up in the wrong cell if dy is negative.
    if (autobs)
    {
        x = prevx;
        y = prevy;
    }
    x /= 8;
    y /= 16;

    // It if seemed autobackspaced but there is no "primary" character
    // yet, then it isn't actually.
    if (textmap[y * 64 + x][0] == '\0')
    {
        autobs = false;
    }
    
    if (autobs)
    {
        // This is an autobackspaced character, so put it into the 
        // second or third slot of the textmap entry.  Special case:
        // if the previous one is grave and this is acute, replace the
        // existing accent by hacek, because that's how hacek is sent 
        // on classic terminals.
        if (textmap[y * 64 + x][1] == '\0')
        {
            textmap[y * 64 + x][1] = c;
        }
        else if (c == L'\u0301' && textmap[y * 64 + x][1] == L'\u0300')
        {
            textmap[y * 64 + x][1] = L'\u030c';
        }
        else
        {
            textmap[y * 64 + x][2] = c;
        }
    }
    else
    {
        textmap[y * 64 + x][0] = c;
        textmap[y * 64 + x][1] = '\0';
        textmap[y * 64 + x][2] = '\0';
        textmap[y * 64 + x][3] = '\0';

        // Also save the current x/y as previous
        prevx = savex;
        prevy = savey;
    }
    
    if (large_p)
    {
        x = (x + 1) & 077;
        textmap[y * 64 + x][0] = '\0';
        textmap[y * 64 + x][1] = '\0';
        textmap[y * 64 + x][2] = '\0';
        textmap[y * 64 + x][3] = '\0';
        y = (y + 1) & 037;
        textmap[y * 64 + x][0] = '\0';
        textmap[y * 64 + x][1] = '\0';
        textmap[y * 64 + x][2] = '\0';
        textmap[y * 64 + x][3] = '\0';
        x = (x - 1) & 077;
        textmap[y * 64 + x][0] = '\0';
        textmap[y * 64 + x][1] = '\0';
        textmap[y * 64 + x][2] = '\0';
        textmap[y * 64 + x][3] = '\0';
    }

    return autobs;
}

// Return the content of the currently selected text region, as a wxString.
// If "url" is true, leading and trailing spaces are trimmed off, and
// for a multi-line region the lines are concatenated without a newline.
// Also, the resulting string is run through a URL processor to escape
// any characters not valid as literal characters in a URL.
// If "url" is false (default), leading spaces are kept, and for a multi-line
// region the lines are separated by newline (CRLF in the Windows case).
wxString PtermFrame::GetRegionText (bool url) const
{
    int i, j, k;
    wxString text;
    wxString c;
    
    if (m_regionHeight == 0 || m_regionWidth == 0)
    {
        debug ("GetRegionText: empty region");
        return text;
    }
    
    // regionX and regionY are the lowest coordinate corner of
    // the copy region, i.e., the lower left corner, expressed in
    // 0-based coarse grid coordinates.
    for (i = m_regionY + m_regionHeight - 1; i >= m_regionY; i--)
    {
        wxString line;
        
        for (j = m_regionX; j < m_regionX + m_regionWidth; j++)
        {
            c = textmap[i * 64 + j];
            // Each textmap entry can be up to 3 characters, for example
            // for accent marks (stored as combining accent), or for
            // various overstruck special characters like universal delimiter.
            // So if the entry is longer than one character code, search
            // for match in the combinations we know.
            if (c.Len () > 1)
            {
                for (k = 0; 
                     k < sizeof (autobsmap) / sizeof (autobsmap[0]);
                     k++)
                {
                    if (c == autobsmap[k].s)
                    {
                        c = autobsmap[k].c;
                        break;
                    }
                }
                
                // If we didn't find a match, keep only the first
                // character unless the others are accent marks.
                if (c.Len () > 1)
                {
                    if (!(c[1] >= L'\u0300' && c[1] <= L'\u033f' &&
                        (c.Len () == 2 ||
                        (c[2] >= L'\u0300' && c[2] <= L'\u033f'))))
                    {
                        c = c[0];
                    }
                }
            }
            line.Append (c);
            // Copyright takes 3 positions: left paren, copyright body,
            // right paren.  Copyright body is recognized as an autobackspaced
            // form above (for classic -- ascii sends it as one character).
            // But we need to strip off the ( ).
            line.Replace (L"(\u00A9)", L"\u00A9");
        }
        // Strip off trailing spaces
        if (m_trimEnd)
            line.Trim (true);
        if (url)
        {
            // Strip off leading/trailing spaces
            if (!m_trimEnd)
                line.Trim (true);
            line.Trim (false);
        }
        else
        {
            if (m_regionHeight > 1)
            {
#if defined (__WXMSW__)
                // Windows really likes a CRLF and it must be done
                // on two separate function calls.  (really? gpk)
                line.Append (wxT ('\r'));
#endif
                line.Append (wxT ('\n'));
            }
        }
        text.Append (line);
    }
    if (url)
    {
        wxURI u (text);
        text = u.BuildURI ();
    }
#ifdef DEBUG
    debug ("GetRegionText (%d) returns:", (int) url);
    debug (text);
#endif
    return text;
}

void PtermFrame::ClearRegion (void)
{
    // Cancel any region selection
    if (m_regionHeight != 0 || m_regionWidth != 0)
    {
        m_regionHeight = 0;
        m_regionWidth = 0;
        menuBar->Enable (Pterm_Copy, false);
        menuBar->Enable (Pterm_Exec, false);
        menuBar->Enable (Pterm_MailTo, false);
        menuBar->Enable (Pterm_SearchThis, false);
        menuPopup->Enable (Pterm_Copy, false);
        menuPopup->Enable (Pterm_Exec, false);
        menuPopup->Enable (Pterm_MailTo, false);
        menuPopup->Enable (Pterm_SearchThis, false);
        if (m_statusBar != NULL)
        {
            m_statusBar->SetStatusText (wxT (""), STATUS_TIP);
        }
        m_canvas->Refresh (false);
    }
}

void PtermFrame::UpdateRegion (int x, int y, int mouseX, int mouseY)
{
    int x1, x2, y1, y2, mtoler;
    wxString msg;
    int scfx, scgx, ecfx, ecgx;

    mtoler = (m_DisableMouseDrag) ? 512 : MouseTolerance;
    
    if (abs (x - mouseX) > mtoler || abs (y - mouseY) > mtoler)
    {
        // It was a mouse drag (region selection)
        // rather than a click
        if (mouseX > x)
        {
            x1 = x;
            x2 = mouseX;
        }
        else
        {
            x1 = mouseX;
            x2 = x;
        }
        if (mouseY > y)
        {
            y1 = y;
            y2 = mouseY;
        }
        else
        {
            y1 = mouseY;
            y2 = y;
        }
        x1 = BOUND (x1);
        x2 = BOUND (x2);
        y1 = BOUND (y1);
        y2 = BOUND (y2);
        m_regionX = x1 / 8;
        m_regionY = y1 / 16;
        m_regionWidth = (x2 + 1 - (m_regionX * 8)) / 8;
        m_regionHeight = (y2 - (m_regionY * 16)) / 16 + 1;
        menuBar->Enable (Pterm_Copy, (m_regionWidth > 0));
        menuBar->Enable (Pterm_Exec, (m_regionWidth > 0)); 
        menuBar->Enable (Pterm_MailTo, (m_regionWidth > 0)); 
        // This one is enabled only if (a) there is a region, and (b)
        // the search URL is set.
        menuBar->Enable (Pterm_SearchThis,
                         m_regionWidth > 0 && !m_SearchURL.IsEmpty ()); 
        menuPopup->Enable (Pterm_Copy, (m_regionWidth > 0));
        menuPopup->Enable (Pterm_Exec, (m_regionWidth > 0)); 
        menuPopup->Enable (Pterm_MailTo, (m_regionWidth > 0)); 
        menuPopup->Enable (Pterm_SearchThis,
                           m_regionWidth > 0 && !m_SearchURL.IsEmpty ()); 
        debug ("region %d %d size %d %d", m_regionX, m_regionY,
               m_regionWidth, m_regionHeight);
        m_canvas->Refresh (false);
        return;
    }
    if (m_regionWidth == 0 && m_regionHeight == 0)
        msg = wxT ("");
    else
    {
        scfx = 256 - 4 * m_regionWidth;
        ecfx = 256 + 4 * m_regionWidth;
        if ((scfx % 8) == 0)
        {
            scgx = (scfx / 8) + 1;
            ecgx = scgx + m_regionWidth - 1;
            msg.Printf (wxT ("%dx%d, f=%d-%d, g=%02d-%02d"),
                        m_regionWidth, m_regionHeight, 
                        scfx, ecfx, scgx, ecgx);
        }
        else
            msg.Printf (wxT ("%dx%d, f=%d-%d"),
                        m_regionWidth, m_regionHeight, scfx, ecfx);
    }
    if (m_statusBar != NULL)
    {
        m_statusBar->SetStatusText (msg, STATUS_TIP);
    }
}

const char* PtermFrame::resCallName(u16 pc)
{
    switch (pc)
    {
    case R_MAIN:
        return "r.main  ";

    case R_INIT:
        return "r.init  ";

    case R_DOT:
        return "r.dot   ";

    case R_LINE:
        return "r.line  ";

    case R_CHARS:
        return "r.chars ";

    case R_BLOCK:
        return "r.block ";

    case R_INPX:
        return "r.inpx  ";

    case R_INPY:
        return "r.inpy  ";

    case R_OUTX:
        return "r.outx  ";

    case R_OUTY:
        return "r.outy  ";

    case R_XMIT:
        return "r.xmit  ";

    case R_MODE:
        return "r.mode  ";

    case R_STEPX:
        return "r.stepx ";

    case R_STEPY:
        return "r.stepy ";

    case R_WE:
        return "r.we    ";

    case R_DIR:
        return "r.dir   ";

    case R_INPUT:
        return "r.input ";

    case R_SSF:
        return "r.ssf   ";

    case R_CCR:
        return "r.ccr   ";

    case R_EXTOUT:
        return "r.extout";

    case R_EXEC:
        return "r.execx ";

    case R_GJOB:
        return "r.gjob  ";

    case R_XJOB:
        return "r.xjob  ";

    case R_ALARM:
        return "r.alarm ";

    case R_FCOLOR:
        return "r.fcolor";

    case R_FCOLOR + 1: 
        return "c.fcolor";

    case R_BCOLOR: 
        return "r.bcolor";

    case R_BCOLOR + 1:
        return "c.bcolor";

    case R_PAINT: 
        return "r.paint ";

    case R_PAINT + 1:
        return "c.paint ";

    case R_PAINT + 2:
        return "c.mark  ";

    case R_WAIT16:
        return "r.wait16";

    case R_DUMMY2:
        return "r.dummy2";

    case R_DUMMY3:
        return "r.dummy3";

    default:
        return "unknown ";
    }
}

// This emulates the "ROM resident".  Return values:
// 0: PC is not special (not in resident), proceed normally.
// 1: PC is ROM function entry point, it has been emulated,
//    do a RET now.
// 2: PC is either the z80 emulation exit magic value, or R_INIT,
//    or an invalid resident value.  Exit z80 emulation.

int PtermFrame::check_pcZ80(void)
{
    int x, y, cp, c, x2, y2;
    
    if (state->pc < WORKRAM && m_MtTrace)
    {
        tracex("Resident call %04x %s DE=%04x HL=%04x",
            state->pc, resCallName(state->pc), state->registers.word[Z80_DE], state->registers.word[Z80_HL]);
    }
    
    switch (state->pc)
    {
    case R_MAIN:
        // "r.main" -- fake return address value used as the return
        // address for invocations of the mode 5/6/7 handler code

        m_canvas->Refresh(false);

        return 2;

    case R_INIT:
        // r.init -- TBD

        m_canvas->Refresh(false);

        m_statusBar->SetStatusText (_(" Program ended"), STATUS_CONN);

        return 2;
        
    case R_DOT:

        x = state->registers.word[Z80_HL] & 0x1ff;
        y = state->registers.word[Z80_DE] & 0x1ff;

        ptermDrawPoint (x, y);
        currentX = x;
        currentY = y;
        m_canvas->Refresh (false);
        return 1;
        
    case R_LINE:
        x = state->registers.word[Z80_HL] & 0x1ff;
        y = state->registers.word[Z80_DE] & 0x1ff;
        ptermDrawLine (currentX, currentY, x, y);
        currentX = x;
        currentY = y;
        m_canvas->Refresh (false); 
        return 1;

    case R_CHARS:
        // draw chars ending at 07700
        cp = state->registers.word[Z80_HL];
        c = RAM[cp++];
        for (;;)
        {
            if (c == 077 && RAM[cp] == 0)
            {
                break;
            }

            u8 save = RAM[M_CCR];
            u16 charM = (RAM[M_CCR] & 0x0e) >> 1; // Current M slot

            if (c > 0x3F )
            {
                // advance M slot by one
                RAM[M_CCR] = (RAM[M_CCR] & ~0x0e) | (charM + 1) << 1;
            }

            plotChar (c & 0x3f );

            if (c > 0x3F )
            {
                // restore M slot
                RAM[M_CCR] = save;
            }

            c = RAM[cp++];
        }
        m_canvas->Refresh (false);
        return 1;
        
    case R_BLOCK:
        // block erase
        cp = state->registers.word[Z80_HL];
        x = ReadRAMW (cp) & 0x1ff;
        y = ReadRAMW (cp + 2) & 0x1ff;
        x2 = ReadRAMW (cp + 4) & 0x1ff;
        y2 = ReadRAMW (cp + 6) & 0x1ff;
        ptermBlockErase (x, y, x2, y2);
        m_canvas->Refresh (false);
        return 1;
        
    case R_INPX:
        state->registers.word[Z80_HL] = currentX;
        return 1;

    case R_INPY:
        state->registers.word[Z80_HL] = currentY;
        return 1;
        
    case R_OUTX:
        currentX = state->registers.word[Z80_HL] & 0x01ff;
        return 1;
        
    case R_OUTY:
        currentY = state->registers.word[Z80_HL] & 0x01ff;
        return 1;
        
    case R_XMIT:
        // send key in HL
    {
        int k = state->registers.word[Z80_HL];
        u8 temp_hold = mt_ksw;
        if (k != 0x3a)
            mt_ksw = 0;
        ptermSendKey1(k);
        mt_ksw = temp_hold;
    }
        return 1;
        
    case R_MODE:
        // set mode from L

        u8 L;
        L = state->registers.byte[Z80_L];
        if (L & 1)
        {
            ptermFullErase ();
        }
        modexor = false;
        mode = (L >> 1) & 037;
        return 1;
        
    case R_STEPX:
        currentX = (currentX + ((RAM[M_DIR] & 2) ? -1 : 1)) & 0777;
        return 1;
        
    case R_STEPY:
        currentY = (currentY + ((RAM[M_DIR] & 1) ? -1 : 1)) & 0777;
        return 1;
        
    case R_WE:
        ptermDrawPoint (currentX, currentY);
        m_canvas->Refresh (false);
        return 1;
        
    case R_DIR:
        L = state->registers.byte[Z80_L];
        RAM[M_DIR] = L & 3;
        return 1;
        
    case R_INPUT:
#if 0   // disable with level 2 patch of execerr getkey loop
        if (m_mtutorBoot)  // this is very bad for performance, 
                           // intolerable on-line, even crashes
        {
            int ms = 1;
            m_canvas->Refresh(false);
            Mz80Waiter(ms);
            m_giveupz80 = true;
        }
#endif

        if (tracePterm)
        {
            tracex("R_INPUT: %04x", mt_key);
            //printf("\nR.INPUT %04x\n", mt_key);   // temp
        }
        state->registers.word[Z80_HL] = mt_key & 0xffff;
        mt_key = -1;

        return 1;
        
    case R_SSF:
        // r.ssf
    {
        int n;
        n = state->registers.word[Z80_HL];

        int device = (n >> 10) & 0x1f;
        int writ = (n >> 9) & 0x1;
        int inter = (n >> 8) & 0x1;
        int data = n & 0xff;

        //printf("r.ssf input=%04x\n", n);
        //printf("r.ssf device=%02x\n", device);
        //printf("r.ssf W=%01x\n", writ);
        //printf("r.ssf I=%01x\n", inter);
        //printf("r.ssf data=%02x\n", data);

        m_enab = data;

        // remember devices
        if(writ == 1)
        {
            m_indev = device;
        }
        else
        {
            m_outdev = device;
        }

        if (device == 15 && writ == 1 && inter == 0)   
        {  
            if ((m_mtincnt & 3) == 0)
            {
                state->registers.byte[Z80_L] = 0xcc;
            }
            else if ((m_mtincnt & 3) == 1)
            {
                state->registers.byte[Z80_L] = 0x63;
            }
            else if ((m_mtincnt & 3) == 2)
            {
                state->registers.byte[Z80_L] = 0x33;
            }
            else
            {
                state->registers.byte[Z80_L] = 0x40;        // cdc disk resident loaded/running
            }
            m_mtincnt++;            // rotating selection of 3 possible responses
                                    // mtutor tries many times

            //printf("r.ssf returns=%02x\n\n", state->registers.byte[Z80_L]);
        }

        switch (n)
        {
        case 0x1f00:    // xin 7; means start CWS functions
            trace("R_SSF; start cws mode; %04x", n);
            cwsmode = 1;
            break;
        case 0x1d00:    // xout 7; means stop CWS functions
            trace("R_SSF; stop cws mode; %04x", n);
            cwsmode = 2;
            break;
        case -1:
            break;
        default:
            if (device == 1 && writ == 0)
            {
                trace("R_SSF %04x", n);
                m_canvas->ptermTouchPanel((data & 0x20) != 0);
            }
            break;
        }
    }
        return 1;
        
    case R_CCR:
        RAM[M_CCR] = state->registers.byte[Z80_L];
        return 1;
        
    case R_EXTOUT:
        // r.extout

        //printf("r.extout data=%04x\n", HL.pair);

        return 1;
        
    case R_EXEC:
        // r.exec
        trace ("R.EXEC");
        Mz80Waiter(RESIDENTMSEC);
        m_giveupz80 = true;
        //SaveRestoreColors (save, micro);
        //SaveRestoreColors (restore, host);
        return 1;
        
    case R_GJOB:
        // r.gjob
        return 1;
        
    case R_XJOB:
        // r.xjob
        return 1;

    case R_RETURN: //obsolete
        return 1;

    case R_CHRCV:
        {
            u16 src = state->registers.word[Z80_DE];
            u16 cnt = state->registers.word[Z80_HL] * 8;
            u16 slot = (state->registers.word[Z80_DE] - ReadRAMW(C2ORIGIN)) / 16;
            memaddr = 16*slot + ReadRAMW(C2ORIGIN);
            for( int i = 0 ; i < cnt ; i++)
            {
                mode2(ReadRAMW(src));
                src = src + 2;
            }
        }
        return 1;

    case R_ALARM:
        wxBell();
        return 1;

    case R_FCOLOR:      // for standard use with h, l, d
        //  three bytes are r g b
    {
        wxColour color(state->registers.byte[Z80_H], 
            state->registers.byte[Z80_L], 
            state->registers.byte[Z80_D]);
        m_currentFg = color;
        SetColors(m_currentFg, m_currentBg);
    }
        return 1;

    case R_FCOLOR + 1:      // for mtutor ccode use with de
        // de points to 3 byte foreground color
        //  three bytes are r g b
    {
        wxColour color(RAM[state->registers.word[Z80_DE]], 
            RAM[state->registers.word[Z80_DE] + 1], 
            RAM[state->registers.word[Z80_DE] + 2]);
        m_currentFg = color;
        SetColors(m_currentFg, m_currentBg);
    }
        return 1;

    case R_FCOLOR + 2:  // for mtutor floating color
        {
        m_currentFg = GetColor (state->registers.word[Z80_HL]);
        SetColors (m_currentFg, m_currentBg);
        }
        return 1;

    case R_BCOLOR:      // for standard use with h, l, d
        // three bytes are r g b

    {
        wxColour colorb(state->registers.byte[Z80_H], 
            state->registers.byte[Z80_L], 
            state->registers.byte[Z80_D]);
        m_currentBg = colorb;
        SetColors(m_currentFg, m_currentBg);
    }
        return 1;

    case R_BCOLOR + 1:      // for mtutor ccode use with de
        // de points to 3 byte background color
        // three bytes are r g b

    {
        wxColour colorb(RAM[state->registers.word[Z80_DE]], 
            RAM[state->registers.word[Z80_DE] + 1], 
            RAM[state->registers.word[Z80_DE] + 2]);
        m_currentBg = colorb;
        SetColors(m_currentFg, m_currentBg);
    }
        return 1;

    case R_BCOLOR + 2:
    {
        m_currentBg = GetColor (state->registers.word[Z80_HL]);
        SetColors (m_currentFg, m_currentBg);
    }
        return 1;

    case R_PAINT:       // standard
        ptermPaint(state->registers.word[Z80_HL]);
        m_canvas->Refresh (false);
        return 1;

    case R_PAINT + 1:   // mtutor ccode
        ptermPaint(RAM[state->registers.word[Z80_DE]] |
            (RAM[state->registers.word[Z80_DE] + 1] << 8));
        m_canvas->Refresh (false);
        return 1;

    case R_PAINT + 2:   // mtutor ccode - usefull for debugging
        printf("MTUTOR LESSON MARK %d\n", (RAM[state->registers.word[Z80_DE]] << 8) |
            (RAM[state->registers.word[Z80_DE] + 1]));
        return 1;

    case R_WAIT16:  // 0x0097
        // for use with mtutor timed -pause-
        wxMilliSleep(15);

        return 1;

    case R_WAIT16 + 1:
        // standard interface with HL
        wxMilliSleep (state->registers.word[Z80_HL]);

        return 1;

    case R_WAIT16 + 2:
        // interface with DE for use with mtutor -ccode-
        wxMilliSleep (ReadRAMW(state->registers.word[Z80_DE]));

        return 1;

    case R_DUMMY2:

        return 1;

    case R_DUMMY3:

        return 1;

    default:
        if (state->pc < WORKRAM)
        {
            // Wild jump into ROM resident, quit
            fprintf (stderr, "Wild jump to %04x\n", state->pc);
            printf("Wild jump/call/ret to %04x\n", state->pc);
            trace("Wild jump/call/ret to %04x\n", state->pc);

            // no longer send keys to mtutor; it's dead
            mt_ksw &= 0xfe;
            m_mtutorBoot = false;

            return 2;
        }
        else
        {
            // Plain old RAM PC -- keep executing
            return 0;
        }
    }
}

wxColour PtermFrame::GetColor (u16 loc)
{
    u8 exp = RAM[loc + 1];

    u32 cb = RAM[loc + 2] << 16;
    cb |= RAM[loc + 3] << 8;
    cb |= RAM[loc + 4];

    cb = cb >> (0x18 - exp);

    wxColour color ((cb>>16) & 0xff, (cb >> 8) & 0xff, (cb) & 0xff);
    return color;
}

void PtermFrame::SaveRestoreColors (u8 action, u8 target)
{
    if (target == host)
    {
        if (action == restore)
        {
            SetColors (m_currentFgHost, m_currentBgHost);
        }
        else
        {
            m_currentFgHost = m_currentFg;
            m_currentBgHost = m_currentBg;
        }
    }
    else
    {
        if (action == restore)
        {
            SetColors (m_currentFgLocal, m_currentBgLocal);
        }
        else
        {
            m_currentFgLocal = m_currentFg;
            m_currentBgLocal = m_currentBg;
        }
    }

}

void PtermFrame::BootMtutor()
{
    if (m_floppy0 && m_floppy0File.Length() > 0)
        m_MTFiles[0].Open(m_floppy0File);
    else
        m_MTFiles[0].Close();

    if (m_floppy1 && m_floppy1File.Length() > 0)
        m_MTFiles[1].Open(m_floppy1File);
    else
        m_MTFiles[1].Close();

    ResetProc();

    m_MTFiles[0].Seek(25);
    u8 boot1 = m_MTFiles[0].ReadByte();
    if (boot1 == 0)
    {
        wxLogError("Cannot Boot - no router set");
        return;
    }

    // read level of disk for patch set to use
    m_MTFiles[0].Seek (36);
    m_mtPLevel = m_MTFiles[0].ReadByte ();
    m_MTFiles[0].ReadReset ();
    m_MTFiles[0].Seek(21504);   // read interp. into ram
    u16 address = 0x5300;       // interp fwa
    u16 sectors;
    u16 bytes;
    u16 readnum = 0;
    if (m_mtPLevel == 2)
    {
        readnum = 80;
    }
    else if (m_mtPLevel == 3)
    {
        readnum = 81;
    }
    else if (m_mtPLevel == 4)
    {
        readnum = 82;
    }
    else if (m_mtPLevel == 5)
    {
        readnum = 82;
    }
    else if (m_mtPLevel == 6)
    {
        readnum = 82;
    }

    // readnum sectors long
    for (sectors = 0 ; sectors < readnum; sectors++)
    {
        for (bytes = 0; bytes < 128; bytes++)
        {
            RAM[address++] = m_MTFiles[0].ReadByte();
        }
        m_MTFiles[0].ReadByte();        // omit check bytes
        m_MTFiles[0].ReadByte();
    }

    state->pc = 0x5306;    // f.inix - boot entry point

    m_mtutorBoot = true;

    if (tracePterm)
    {
        tracex("boot to mtutor");
    }
    SaveRestoreColors (save, host);

    MicroEmulate;
}

/*******************************************************************************

inputz80:
----------

   This case switches on the content of data.  If the content of data is equal
to 1, ...
The program counter, named PC, is incremented by one.


Input:
-----

   data - This variable is the byte after the INp instruction, RAM[PC].


Output:
------

   This variable is the data that has been read or calculated from the input
device and returned to the main simulator core.


Note:
----

   This function is called directly by Z80::emulate.

*******************************************************************************/

/*
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    NOTE:  this routine obviously needs some more work, as it has
    paths thru it (case 1, 2) that can pass thru the routine without
    setting the value of -retval-.  --bg 2010/06/18
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/


u8 PtermFrame::inputZ80(u8 data)
{

    /***********************************************************************
    * Declaration:
    * -----------
    *
    *   retval - This variable contains data read from an input device.
    ***********************************************************************/
    u8 retval;

    switch (data)
    {

    /***********************************************************************
    *   If the value of the z80's memory, RAM[PC], is equal to 1 or 2,
    * then first or second player input is requested.
    ***********************************************************************/
        case 1:
        case 2:
            retval = 0;
            break;
        // below used by mtutor
        case 0x2a:
            retval = 0x37;
            break;
        case 0x2b:
            retval = 1;
            break;
        case 0xaa:  // new in level 4
            retval = 0x37 + 1;
            break;

        case 0xab:  // new in level 4
            retval = 0x01;
            break;

        case 0xae:          // cdc disk data port
            retval = 0;     // default
            switch (m_mtdrivefunc)
            {
            case 0:
                // read next byte of data from disk
                retval = m_MTFiles[m_mtDiskUnit&1].ReadByte();
                break;
            case 2: // write data to disk - noop
                break;
            case 11:
                // read millisec clock - called twice - for lower and upper
                {
                    u16 temp = m_zclock;
                    retval = m_clockPhase ? (temp & 0xff) : ((temp << 8) & 0xff);
                    m_clockPhase = !m_clockPhase;
                }
                break;
            case 4:
                retval = m_mtsingledata;  // d.rcid
                break;
            case 8:     // d.clear
                break;
            default:
                break;
            }
            //printf("CDC drive DATA responding to: %02x  with:  %02x\n", m_mtdrivefunc, retval);
            break;
        case 0xaf:          // cdc disk control port
            retval = m_mtcanresp;
            //printf("CDC drive control responding to: %02x  with:  %02x\n", m_mtdrivefunc, retval);
            switch (m_mtdrivefunc)
            {
            case 0:
            case 2:
            case 11:
                m_mtcanresp = 0x50;
                break;

            default:
                break;

            }

            break;

    /***********************************************************************
    *   If the value of the z80's memory, RAM[PC], is not equal to any of
    * the above cases, then the program requested bad input data. Debug
    * information containing the value of the data is printed to STDOUT.
    ***********************************************************************/
        default:
            printf ("INp BAD -> Data = %d\n", data);

            retval = 0;
            break;
    }

    /***********************************************************************
    *   This keyword returns the read input data to the main simulator core.
    ***********************************************************************/
    return retval;
}



/*******************************************************************************

outputz80:
-----------

   This case switches on the contents of the data.  If the content of data is
equal to 2, ...
If the content of data is any other value, then the request is bad and 
debugging information is printed to STDOUT.


Input:
-----

   data - This variable is the byte after the OUTp instruction, RAM[PC].
   acc - This variable is the accumulator, which is the z80's A register.


Note:
----

   This function is called directly by Z80::emulate.

*******************************************************************************/
void PtermFrame::outputZ80(u8 data, u8 acc)
{
    u8 comp = ~acc;
    bool ok = comp == m_mtdrivetemp;

    //printf("out: %02x, %02x\n", data, acc);

    switch (data)
    {

    /***********************************************************************
    *   If the value of the z80's memory, RAM[PC], is equal to 2, the
    * content of the A register is moved into the left shift amount.
    ***********************************************************************/
        case 2:
        // below used by mtutor 
        case 0x2b:
            break;

        case 0xab:  // new in level 4

            break;

        case 0xae:      // CDC drive data port
            switch (m_mtdrivefunc)
            {
            case 0: // read disk
            case 2: // write data to disk - and recieve setup data
                //if (m_mtdrivefunc == 10)
                //    printf("CDC drive DATA WRITE");
                switch (m_mtDataPhase++)
                {
                    case 1:
                        m_mtDiskUnit = acc;
                        break;
                    case 2:
                        m_mtDiskTrack = acc;
                        break;
                    case 3:
                        m_mtDiskSector = acc;
                        break;
                    case 4:
                        m_mtDisk1 = acc;
                        break;
                    case 5:
                        m_mtDisk2 = acc;
                        break;
                    case 6:
                        m_mtDiskCheck1 = acc;
                        break;
                    case 7: // 128 bytes/sector plus two check bytes
                        m_mtDiskCheck2 = acc;

                        m_mtSeekPos = (128 * 64 * m_mtDiskTrack) + (128 * (m_mtDiskSector-1));
                        if (m_mtSeekPos < 0)
                            break;
                        m_MTFiles[m_mtDiskUnit&1].Seek(m_mtSeekPos);
                        break;

                    default:   // write data
                        m_MTFiles[m_mtDiskUnit&1].WriteByte(acc);
                        m_mtcanresp = 0x50;
                        break;
                }
                break;

            case 10: // format
                switch (m_mtDataPhase++)
                {
                case 1:
                    m_mtDiskUnit = acc;
                    break;
                case 2:
                    m_mtDiskTrack = acc;
                    break;
                case 3:
                    m_mtDiskSector = acc;
                    break;
                case 4:
                    m_mtDisk1 = acc;
                    break;
                case 5:
                    m_mtDisk2 = acc;
                    //break;
                default:
                    m_MTFiles[m_mtDiskUnit & 1].Format();
                    break;
                }
                break;

            //case 11:
            //    // read millisec clock - noop
            //break;

            //case 4:  // noop
            //case 8:  // d.clear - noop
            //    break;

            default:
                break;

            }
            //printf("CDC drive DATA recieving for: %02x  data:  %02x\n", m_mtdrivefunc, acc);
            break;

        case 0xaf:      // CDC drive control port
            if (ok)     // accept function
            {
                m_mtdrivefunc = m_mtdrivetemp;
                m_mtdrivetemp = 0xcb;
                m_mtDataPhase = 1;

                switch(m_mtdrivefunc)
                {
                case 0:
                case 2:
                case 10:
                case 11:
                    m_mtcanresp = 0x4a;
                    m_clockPhase = true;
                    break;

                case 4:
                    m_mtcanresp = 0x4a;
                    m_mtsingledata = 0x02;
                    if (m_floppy1)
                    {
                        m_mtsingledata |= 0x80;
                    }
                    break;

                case 8:
                    m_mtcanresp = 0x50;
                    break;

                default:
                    m_mtsingledata = 2;  // remove me
                    break;
                }
                //printf("CDC drive control accept: %02x\n", m_mtdrivefunc);
            }
            else
            {
                m_mtdrivetemp = acc; // set function
                //printf("CDC drive control command: %02x\n", m_mtdrivetemp);
                m_mtcanresp = 0x48;
            }
            
            break;


    /***********************************************************************
    *   If the value of the z80's memory, RAM[PC], is not equal to any of
    * the above cases, then the program requested bad output data.  Debug
    * information containing the value of the data and the accumulator are
    * printed to STDOUT.
    ***********************************************************************/
        default:
            printf ("OUTp BAD -> Data = %d   A = %d\n", data, acc);
            break;
    }
}
